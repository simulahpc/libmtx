This is libmtx.info, produced by makeinfo version 6.7 from
libmtx.texi.

This manual describes how to install and use libmtx, version
0.1.0, 18 June 2021, a C library and collection of utility programs for
working with objects in the Matrix Market file format, including
vectors, dense matrices and sparse matrices.

   Copyright (C) 2021 James D. Trotter

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included in
     the section entitled "GNU Free Documentation License".
INFO-DIR-SECTION Mathematics
START-INFO-DIR-ENTRY
* libmtx: (libmtx).         C library and utility programs for working with Matrix Market files.
END-INFO-DIR-ENTRY


File: libmtx.info,  Node: Top,  Next: Copying,  Up: (dir)

libmtx
***************

This manual describes how to install and use libmtx, version
0.1.0, 18 June 2021, a C library and collection of utility programs for
working with objects in the Matrix Market file format, including
vectors, dense matrices and sparse matrices.

   Copyright (C) 2021 James D. Trotter

     Permission is granted to copy, distribute and/or modify this
     document under the terms of the GNU Free Documentation License,
     Version 1.3 or any later version published by the Free Software
     Foundation; with no Invariant Sections, with no Front-Cover Texts,
     and with no Back-Cover Texts.  A copy of the license is included in
     the section entitled "GNU Free Documentation License".

* Menu:

* Copying:: libmtx Copying Conditions (GPLv3).
* Introduction to libmtx:: Brief introduction to libmtx.
* Installing libmtx:: How to configure and compile libmtx.
* Reporting Bugs:: How to usefully report bugs.
* Matrix Market file format:: Description of the Matrix Market format.
* Matrix Market objects:: Working with matrices and vectors in the Matrix Market format.
* Commands:: Command-line tools for Matrix Market files.
* C library reference:: Reference for the C library data types and functions.

* References:: List of useful references.
* GNU Free Documentation License:: Copying and sharing this documentation.
* General index:: Index of general concepts.
* Function index:: Index of functions.
* Data type index:: Index of data type.
* Program index:: Index of programs.


File: libmtx.info,  Node: Copying,  Next: Introduction to libmtx,  Prev: Top,  Up: Top

libmtx Copying Conditions
**********************************

libmtx is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

   libmtx is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
Public License for more details.

   You should have received a copy of the GNU General Public License
along with libmtx.  If not, see
<https://www.gnu.org/licenses/>.


File: libmtx.info,  Node: Introduction to libmtx,  Next: Installing libmtx,  Prev: Copying,  Up: Top

1 Introduction to libmtx
*********************************

The "libmtx" C library and its accompanying utility programs
are a collection of basic tools for working with Matrix Market files.
In scientific computing, the Matrix Market format is a commonly used,
human-readable text file format for storing both dense and sparse
matrices and vectors.

   Matrices and vectors are basic objects of numerical linear algebra
and thus appear in most fields of science.  In particular, sparse
matrices, where most of the entries are zero, are especially important
for representing sparse graphs and for solving partial differential
equations, to name just two examples.  Sparse matrices require methods
that are different from those used with dense matrices, but, in return,
they often result in significantly fewer arithmetic operations to be
carried out, as well as lower memory footprint and memory bandwidth
usage.

1.1 Background
==============

The 'Matrix Market' (*note National Institute of Standards and
Technology [NIST] (2007)::) is a repository of test data that has been
used to study and compare various algorithms for numerical linear
algebra.  It was originally designed and developed by R. Boisvert, R.
Pozo, K. Remington, R. Barrett and J.J. Dongarra, and first became
available online in February 1996.

   The Matrix Market data set was made available in the Matrix Market
file format, which was initially described in the paper 'The Matrix
Market Formats: Initial Design' (*note R.F. Boisvert, R. Pozo and K.
Remington (1996)::).  There is also a reference software for reading and
writing Matrix Market files, known as "mmio", or the ANSI C library for
Matrix Market I/O, (*note National Institute of Standards and Technology
[NIST] (2000)::).

   More recently, the 'SuiteSparse Matrix Collection'
(<https://sparse.tamu.edu/>) has become a large, widely used repository
of sparse matrices from numerous application domains.  These matrices
are also distributed in the Matrix Market format.

1.2 How to Use This Manual
==========================

To familiarise yourself with the Matrix Market file format, read *note
Matrix Market file format::.  If you need to install the library
yourself, you should read *note Installing libmtx::.  If you
would like to use the libmtx C library, refer to *note Matrix
Market objects::.  If, on the other hand, you would like to get an
overview of the command-line programs for working with Matrix Market
files that are included in libmtx, then you should read *note
Commands::.


File: libmtx.info,  Node: Installing libmtx,  Next: Reporting Bugs,  Prev: Introduction to libmtx,  Up: Top

2 Installing libmtx
****************************

libmtx uses GNU Autotools, which means that a basic build on a
UNIX-like system can be done by running the commands
     ./configure
     make
   To run some tests, use the command
     make check
   Finally, install the programs and library with
     make install

   If you experience problems, please report them to <james@simula.no>.
See *note Reporting Bugs:: for information on what to include in a bug
report.

* Menu:

* Optional dependencies::


File: libmtx.info,  Node: Optional dependencies,  Up: Installing libmtx

2.1 Optional dependencies
=========================

Some features of libmtx are optional and will only be available
if the following dependencies are provided:
   * _MPI_ is needed for distributed-memory parallel matrices and
     vectors.
   * _BLAS_ is needed for various linear algebra operations.  Various
     implementations may be used, such as the netlib reference BLAS,
     OpenBLAS, BLIS, and so on.
   * _zlib_ ('https://www.zlib.net/') is needed for reading and writing
     gzip-compressed Matrix Market files.


File: libmtx.info,  Node: Reporting Bugs,  Next: Matrix Market file format,  Prev: Installing libmtx,  Up: Top

3 Reporting Bugs
****************

To report bugs, suggest enhancements or otherwise discuss
libmtx, please send electronic mail to <james@simula.no>.

   For bug reports, please include enough information for the
maintainers to reproduce the problem.  Generally speaking, that means:

   * The version numbers of libmtx (which you can find by
     running 'mtxinfo --version') and any other program(s) or manual(s)
     involved.
   * Hardware and operating system names and versions.
   * The contents of any input files necessary to reproduce the bug.
   * The expected behavior and/or output.
   * A description of the problem and samples of any erroneous output.
   * Options you gave to 'configure' other than specifying installation
     directories.
   * Anything else that you think would be helpful.

   When in doubt whether something is needed or not, include it.  It's
better to include too much than to leave out something important.

   Patches are welcome; if possible, please make them with 'diff -c'
(*note Overview: (diff)Top.) and include 'ChangeLog' entries (*note
(emacs)Change Log::).  Please follow the existing coding style.


File: libmtx.info,  Node: Matrix Market file format,  Next: Matrix Market objects,  Prev: Reporting Bugs,  Up: Top

4 Matrix Market file format
***************************

This chapter describes the Matrix Market file format.

   Matrix Market files, or '.mtx' files, are plain text ASCII files that
consist of the following four parts:
  1. a "header line",
  2. an optional section containing "comment lines",
  3. a "size line", and
  4. "data lines" for nonzero matrix or vector entries.

Here is an example of a Matrix Market file, which describes a sparse
matrix with 4 rows, 5 columns and 7 real-valued, non-zero entries:
     %%MatrixMarket matrix coordinate real general
     % Sparse matrix example
     4 5 7
     1 2 2.0
     3 3 3.0
     1 1 1.0
     4 5 1.0
     2 2 1.0
     4 1 -1.0
     4 4 2.0
The above example is equivalent to the following 4-by-5 matrix:
      1 2 0 0 0
      0 1 0 0 0
      0 0 3 0 0
     -1 0 0 2 1

   The different parts of a Matrix Market file are described in the
following subsections.

* Menu:

* Header line:: Matrix Market header.
* Comment lines:: Comments in Matrix Market files.
* Size line:: Size of Matrix Market objects.
* Data lines:: Matrix Market data.


File: libmtx.info,  Node: Header line,  Next: Comment lines,  Up: Matrix Market file format

4.1 Header line
===============

The "header line" is on the form:
     %%MatrixMarket OBJECT FORMAT FIELD SYMMETRY
This line always begins with the identifier '%%MatrixMarket' to indicate
that the file is in the Matrix Market format.  The four fields that
follow describe different properties of the Matrix Market object, such
as whether it is a matrix or a vector, and if it is stored in sparse or
dense form.
  1. 'OBJECT' is either 'matrix' or 'vector'.

  2. 'FORMAT' is 'array' if the matrix (or vector) is dense, or
     'coordinate' if it is sparse.

  3. 'FIELD' indicates the field to which the matrix (or vector) values
     belong, and may be one of the following: 'real', 'double',
     'complex', 'integer' or 'pattern'.

  4. 'SYMMETRY' specifies the symmetry properties of a matrix, and may
     be one of the following: 'general', 'symmetric', 'skew-symmetric'
     or 'hermitian'.

   The 'FIELD' value of the header is used as follows:
   * For real-valued matrices (or vectors), values are stored as decimal
     numbers.  'FIELD' is either 'real' or 'double' and values should be
     represented in single- or double-precision floating-point,
     respectively.

   * For complex matrices (or vectors), values are stored as pairs of
     decimal numbers, comprising the real and imaginary parts of a
     complex number.  'FIELD' is 'complex', and values should be
     represented in pairs of single-precision floating-point numbers.

   * For integer-valued matrices (or vectors), values are stored as
     integers.  'FIELD' is 'integer', and values should be represented
     as 32-bit integers.

   * For binary-valued sparse matrices (or vectors), no values are
     stored for nonzero matrix (or vector) entries.  Only the locations
     of nonzeros are stored.  'FIELD' is 'pattern', and only the
     locations of nonzero matrix (or vector) entries should be
     represented.

   The 'SYMMETRY' value of the header is ignored if 'OBJECT' is
'vector'.  However, if 'OBJECT' is 'matrix', then it is used as follows:
   * For a general, unsymmetric matrix, 'SYMMETRY' is 'general'.  Every
     nonzero matrix entry is stored explicitly.

   * For a symmetric matrix, (i.e., a matrix that is equal to its
     transpose), 'SYMMETRY' is 'symmetric'.  The matrix must be square,
     and only the lower or upper triangular part of the matrix is stored
     explicitly.

   * For a Hermitian matrix, (i.e., a matrix that is equal to its
     conjugate transpose), 'SYMMETRY' is 'hermitian'.  The matrix must
     be square, and only the lower or upper triangular part of the
     matrix is stored explicitly.

   * For a skew-symmetric matrix, (i.e., a matrix that is equal to the
     negative of its transpose), 'SYMMETRY' is 'skew-symmetric'.  The
     matrix must be square.  Since skew symmetry implies that diagonal
     entries are zero, only the strictly lower or upper triangular part
     of the matrix is stored explicitly.


File: libmtx.info,  Node: Comment lines,  Next: Size line,  Prev: Header line,  Up: Matrix Market file format

4.2 Comment lines
=================

Matrix Market files allow for an optional section of comments, which are
ignored when processing the file.  If present, comments must follow
immediately after the header line and right before the size line.  Each
comment line begins with the character ''%'' and continues until the end
of the line.


File: libmtx.info,  Node: Size line,  Next: Data lines,  Prev: Comment lines,  Up: Matrix Market file format

4.3 Size line
=============

The "size line" describes the size of the object stored in a Matrix
Market file, and it depends both on the 'OBJECT' and 'FORMAT' values in
the header.

   * For dense vectors, where 'OBJECT' is 'vector' and 'FORMAT' is
     'array', the size line is on the form
          M
     Here, 'M' denotes the number of rows for a row vector, or,
     alternatively, the number of columns for a column vector.  This is
     also the number of vector entries that are stored in the data
     section of the Matrix Market file.

   * For sparse vectors, where 'OBJECT' is 'vector' and 'FORMAT' is
     'coordinate', the size line is on the form
          M NNZ
     Here, 'M' denotes the number of rows for a row vector, or,
     alternatively, the number of columns for a column vector, whereas
     'NNZ' denotes the number of (nonzero) vector entries that are
     explicitly stored in the data section of the Matrix Market file.

   * For dense matrices, where 'OBJECT' is 'matrix' and 'FORMAT' is
     'array', the size line is on the form
          M N
     Here, 'M' and 'N' denote the number of rows and columns in the
     matrix.  Thus, there are 'M*N' matrix entries stored in the data
     section of the Matrix Market file.

   * For sparse matrices, where 'OBJECT' is 'matrix' and 'FORMAT' is
     'coordinate', the size line is on the form
          M N NNZ
     Here, 'M' and 'N' denote the number of rows and columns in the
     matrix, whereas 'NNZ' denotes the number of (nonzero) matrix
     entries that are explicitly stored in the data section of the
     Matrix Market file.


File: libmtx.info,  Node: Data lines,  Prev: Size line,  Up: Matrix Market file format

4.4 Data lines
==============

The final section of a Matrix Market file contains "data lines" for each
nonzero matrix (or vector) entry.  The number of data lines depends on
the matrix (or vector) size, as described in the previous section.

   By default, it is assumed that dense matrix entries are stored in
row-major order.  For sparse matrices and vectors, the nonzero entries
may appear in any order.  Moreover, there may be more than one entry
corresponding to a single location in a sparse matrix or vector.

   The format of a data line depends on the 'OBJECT', 'FORMAT' and
'FIELD' values in the header, as described in the following.

   A dense matrix or vector with real or integer values, that is, when
'FORMAT' is 'array' and 'FIELD' is 'real', 'double' or 'integer', has
data lines on the form
     A
where 'A' is a decimal number in the case of 'real' or 'double', and an
integer otherwise.

   Otherwise, if 'FIELD' is 'complex', then the data lines are on the
form
     A B
   Here 'A' and 'B' are decimal numbers denoting the real and imaginary
parts of the complex number, 'Z=A+B*i', where 'i' is the imaginary unit.

   A sparse matrix, that is, when 'OBJECT' is 'matrix' and 'FORMAT' is
'coordinate', has data lines on one of three different forms depending
on the 'FIELD' value.  Note that indexing of sparse matrix and vector
entries is 1-based.

   * If 'FIELD' is 'real', 'double' or 'integer', then data lines are
     written as:
          I J A
     where 'I' and 'J' denote the row and column index of a nonzero
     entry and 'A' denotes its value.

   * If 'FIELD' is 'complex', then data lines are on the form
          I J A B
     where 'I' and 'J' again denote the row and column index.  Here, 'A'
     is the real part and 'B' is the imaginary part of the complex
     number, 'Z=A+B*i', with 'i' being the imaginary unit.

   * If 'FIELD' is 'pattern', then each data line consists of two
     numbers
          I J
     denoting the row and column index of a nonzero entry.

   For a sparse vector, that is, when 'OBJECT' is 'vector' and 'FORMAT'
is 'coordinate', the data lines are similar to those of a sparse matrix,
but the column index is omitted.  More specifically, data lines are on
one of three different forms depending on the 'FIELD' value.
   * If 'FIELD' is 'real', 'double' or 'integer', then data lines are
     written as:
          I A
     where 'I' denotes the index of a nonzero entry and 'A' denotes its
     value.

   * If 'FIELD' is 'complex', then data lines are on the form
          I A B
     where 'I' again denotes the nonzero index.  Here, 'A' is the real
     part and 'B' is the imaginary part of the complex number,
     'Z=A+B*i', with 'i' being the imaginary unit.

   * If 'FIELD' is 'pattern', then each data line consists of a single
     number
          I
     denoting the index of a nonzero entry.


File: libmtx.info,  Node: Matrix Market objects,  Next: Commands,  Prev: Matrix Market file format,  Up: Top

5 Matrix Market objects
***********************

This chapter provides a detailed explanation of how the libmtx
C library is used.

   For any user-facing types and functions, the library uses the
convention of prefixing their names with 'mtx_'.  This makes it easier
to avoid possible name clashes with other code when using
libmtx.

* Menu:

* Matrix Market data types:: Basic data types for representing Matrix Market objects.
* Error handling:: How to handle errors when working with the libmtx C library.
* Reading and writing Matrix Market files:: Functions for reading from and writing to files in Matrix Market format.
* Creating matrices and vectors:: Functions for creating matrices and vectors.
* Matrix operations:: Matrix operations
* Basic linear algebra operations:: Basic linear algebra
* Communicating matrices and vectors:: Message-passing functions for Matrix Market objects


File: libmtx.info,  Node: Matrix Market data types,  Next: Error handling,  Up: Matrix Market objects

5.1 Matrix Market data types
============================

This section describes the basic data types used to represent objects in
the Matrix Market file format.

   The file 'libmtx/mtx/mtx.h' defines the 'struct mtx' type, which is
used to represent objects in the Matrix Market format.  The definition
of the 'mtx' struct is shown below.
     struct mtx {
       /* Header */
       enum mtx_object object;
       enum mtx_format format;
       enum mtx_field field;
       enum mtx_symmetry symmetry;

       /* Extra header info */
       enum mtx_sorting sorting;
       enum mtx_ordering ordering;
       enum mtx_assembly assembly;

       /* Comments */
       int num_comment_lines;
       char ** comment_lines;

       /* Size */
       int num_rows;
       int num_columns;
       int64_t num_nonzeros;
       int64_t size;
       int64_t nonzero_size;

       /* Data */
       void * data;
     };

   Roughly speaking, the 'mtx' struct consists of four parts: header
information, comment lines, size information, and data.

   Note that a matrix or vector represented by a 'struct mtx' object
will typically have some storage allocated for its data.  As a result,
once the user is finished with the object, it is important to free the
allocated storage by calling 'mtx_free':
     void mtx_free(
         struct mtx * mtx);

   The following sections provide a detailed explanation of the 'mtx'
struct members and their data types.

* Menu:

* Header types::
* Comments::
* Size information::
* Data::
* Additional header types::


File: libmtx.info,  Node: Header types,  Next: Comments,  Up: Matrix Market data types

5.1.1 Header types
------------------

The four enum types, 'mtx_object', 'mtx_format', 'mtx_field' and
'mtx_symmetry' are used to represent values that appear in the Matrix
Market header (see *note Header line::).
     enum mtx_object {
         mtx_matrix,
         mtx_vector
     };

     enum mtx_format {
         mtx_array,     /* array of dense matrix values */
         mtx_coordinate /* coordinate format of sparse matrix values */
     };

     enum mtx_field {
         mtx_real,    /* single-precision floating point coefficients */
         mtx_double,  /* double-precision floating point coefficients */
         mtx_complex, /* single-precision floating point complex
                          * coefficients */
         mtx_integer, /* integer coefficients */
         mtx_pattern  /* boolean coefficients (sparsity pattern) */
     };

     enum mtx_symmetry {
         mtx_general,        /* general, non-symmetric matrix */
         mtx_symmetric,      /* symmetric matrix */
         mtx_skew_symmetric, /* skew-symmetric matrix */
         mtx_hermitian       /* Hermitian matrix */
     };


File: libmtx.info,  Node: Comments,  Next: Size information,  Prev: Header types,  Up: Matrix Market data types

5.1.2 Comments
--------------

Comments are stored in the array 'comment_lines', which consists of
'num_comment_lines' null-terminated strings.


File: libmtx.info,  Node: Size information,  Next: Data,  Prev: Comments,  Up: Matrix Market data types

5.1.3 Size information
----------------------

The size information in 'struct mtx' includes 'num_rows', 'num_columns'
and 'num_nonzeros', which represent the number of rows, column and
nonzeros, respectively.

   Vectors are represented as row vectors, so that 'num_rows' is equal
to the number of elements and 'num_columns' is equal to one.

   For a dense vector or matrix, 'num_nonzeros' is equal to
'num_rows*num_columns'.  Otherwise, it is equal to the total number of
nonzeros in the sparse vector or matrix, including any nonzero entries
that are not explicitly stored due to symmetry.

   'size' is the number of nonzero matrix entries stored in the 'data'
array.  This number depends on the matrix format and symmetry:
   * If 'symmetry' is 'mtx_general', then 'size' is equal to
     'num_nonzeros'.  If 'format' is 'mtx_array', then 'size' and
     'num_nonzeros' are equal to 'num_rows*num_columns'.

   * If 'symmetry' is 'mtx_symmetric' or 'mtx_hermitian', then 'size' is
     the number of nonzero entries on or below the diagonal.  If
     'format' is 'mtx_array', then 'size' is equal to
     '(num_rows+1)*num_rows/2' (or, equivalently,
     '(num_columns+1)*num_columns/2', since 'num_rows' is equal to
     'num_columns').

   * If 'symmetry' is 'mtx_skew_symmetric', then 'size' is the number of
     nonzero entries below the diagonal.  If 'format' is 'mtx_array',
     then 'size' is equal to 'num_rows*num_rows/2' (or, equivalently,
     'num_columns*num_columns/2', since 'num_rows' is equal to
     'num_columns').

   'nonzero_size' is the size (in bytes) of each nonzero stored in the
'data' array.


File: libmtx.info,  Node: Data,  Next: Additional header types,  Prev: Size information,  Up: Matrix Market data types

5.1.4 Data
----------

Nonzero matrix or vector entries are stored in the array 'data', whose
type depends on the values of 'object', 'format' and 'field', as
described below.

   First, consider the case where 'format' is 'mtx_array'.  If 'field'
is 'mtx_real', 'mtx_double' or 'mtx_integer', then 'data' is an array of
'size' values of type 'float', 'double' or 'int', respectively.
Otherwise, if 'field' is 'mtx_complex', then 'data' is an array of
'2*size' values of type 'float'.  (Note that the combination of a matrix
or vector with the 'mtx_array' format and the 'mtx_pattern' field is not
currently supported, though, in principle, it could be implemented in
the form of a bitmap.)

   Second, if 'format' is 'mtx_coordinate', then 'data' is an array of
'size' values of type 'struct mtx_coordinate_OBJECT_FIELD'.  Here
'OBJECT' is 'matrix' or 'vector', corresponding to the 'object' member
of the 'mtx' struct.  Similarly, 'FIELD' is either 'real', 'double',
'complex', 'integer' or 'pattern', corresponding to the 'field' member
of the 'mtx' struct.

   The file 'libmtx/matrix/coordinate/coordinate.h' contains definitions of
data types for representing nonzero values of sparse matrices in
coordinate format.  For matrices with different fields, the data types
are shown below:
     struct mtx_matrix_coordinate_real {
         int i, j; /* row and column index */
         float a;  /* nonzero value */
     };

     struct mtx_matrix_coordinate_double {
         int i, j; /* row and column index */
         double a; /* nonzero value */
     };

     struct mtx_matrix_coordinate_complex {
         int i, j;     /* row and column index */
         float a, b;   /* real and imaginary parts of nonzero value */
     };

     struct mtx_matrix_coordinate_integer {
         int i, j; /* row and column index */
         int a;    /* nonzero value */
     };

     struct mtx_matrix_coordinate_pattern {
         int i, j; /* row and column index */
     };

   The corresponding data types for sparse vectors are defined in the
file 'libmtx/vector/coordinate/coordinate.h'.  These data types are almost
identical to the ones used for sparse matrices, except that the column
index is omitted:error
     struct mtx_vector_coordinate_real {
         int i;    /* row index */
         float a;  /* nonzero value */
     };

     struct mtx_vector_coordinate_double {
         int i;    /* row index */
         double a; /* nonzero value */
     };

     struct mtx_vector_coordinate_complex {
         int i;        /* row index */
         float a, b;   /* real and imaginary parts of nonzero value */
     };

     struct mtx_vector_coordinate_integer {
         int i;    /* row index */
         int a;    /* nonzero value */
     };

     struct mtx_vector_coordinate_pattern {
         int i; /* row index */
     };


File: libmtx.info,  Node: Additional header types,  Prev: Data,  Up: Matrix Market data types

5.1.5 Additional header types
-----------------------------

libmtx also defines some additional enum types that are not
stored explicitly as part of the Matrix Market format, but they can be
provided by the user as additional information about the represented
matrices.

   The first, 'mtx_sorting', is used to enumerate different ways of
sorting matrix entries.
     enum mtx_sorting {
         mtx_unsorted,       /* unsorted matrix nonzeros */
         mtx_row_major,      /* row major ordering */
         mtx_column_major,   /* column major ordering */
     };
   By default, dense matrices are assumed by default to be sorted in
row-major order ('mtx_row_major').  Sparse matrices, on the other hand,
are generally unsorted ('mtx_unsorted') by default.

   Second, 'mtx_ordering' is used to enumerate different orderings or
permutations of the rows and columns of a matrix.  Reordering a sparse
matrix is typically done to improve performance, for example, through
reduced fill-in for matrix factorisations or better data locality.
     enum mtx_ordering {
         mtx_unordered,      /* general, unordered matrix */
         mtx_rcm,            /* Reverse Cuthill-McKee ordering */
     };

   Third, 'mtx_assembly' is used to indicate whether or not a sparse
matrix can contain more than one value for a given row and column index.
In other words, an unassembled matrix often contains several values
associated with each nonzero matrix entry.  Many sparse matrix
operations will only produce correct results whenever these duplicate
matrix entries have been added together first, using a process known as
"assembly".  An assembled matrix may only contain a single, unique value
for each nonzero matrix entry.
     enum mtx_assembly {
         mtx_unassembled, /* unassembled; duplicate nonzeros allowed. */
         mtx_assembled,   /* assembled; duplicate nonzeros not allowed. */
     };

   The enum type 'mtx_partitioning', is used to describe whether the
rows and columns of a distributed matrix or vector form a partition or
merely a cover of the rows and columns of a global matrix or vector.  In
the case of a partition, each matrix or vector entry is owned by a
single MPI process.  In the case of a cover, different MPI processes are
allowed to store values associated with the same matrix or vector entry.
     enum mtx_partitioning {
         mtx_partition,   /* matrix/vector entries are owned
                              * by a single MPI process. */
         mtx_cover,       /* matrix/vector entries may be owned
                              * by multiple MPI processes. */
     };
   Note that some algorithms may only work with a partitioned matrix and
might produce incorrect results in the case of a covering.  Thus, it may
be necessary to first perform a reduction to combine values associated
with matrix or vector entries that are distributed across multiple MPI
processes.


File: libmtx.info,  Node: Error handling,  Next: Reading and writing Matrix Market files,  Prev: Matrix Market data types,  Up: Matrix Market objects

5.2 Error handling
==================

Functions in the libmtx C library generally return a status
code that either indicates success (represented by the status code
'MTX_SUCCESS') or a specific error.  Possible error codes are:
     enum mtx_error
     {
       MTX_SUCCESS = 0,                    /* no error */
       MTX_ERR_ERRNO = -1,                 /* error code provided by errno */
       MTX_ERR_MPI = -2,                   /* MPI error */
       MTX_ERR_EOF = -3,                   /* unexpected end-of-file */
       MTX_ERR_LINE_TOO_LONG = -4,         /* line exceeds maximum length */
       MTX_ERR_INVALID_MTX_HEADER = -5,    /* invalid mtx header */
       MTX_ERR_INVALID_MTX_OBJECT = -6,    /* invalid mtx object */
       MTX_ERR_INVALID_MTX_FORMAT = -7,    /* invalid mtx format */
       MTX_ERR_INVALID_MTX_FIELD = -8,     /* invalid mtx field */
       MTX_ERR_INVALID_MTX_SYMMETRY = -9,  /* invalid mtx symmetry */
       MTX_ERR_INVALID_MTX_SORTING = -10,  /* invalid mtx sorting */
       MTX_ERR_INVALID_MTX_ORDERING = -11, /* invalid mtx ordering */
       MTX_ERR_INVALID_MTX_ASSEMBLY = -12, /* invalid mtx assembly */
       MTX_ERR_INVALID_MTX_SIZE = -13,     /* invalid mtx size info */
       MTX_ERR_INVALID_MTX_DATA = -14,     /* invalid mtx data */
     };

   The function 'mtx_strerror' can be used to give a string containing a
description of a given error code.
     const char * mtx_strerror(int err);
   Here, the integer 'err' should correspond to one of the error codes
from the 'mtx_error' enum type.

   'mtx_strerror' is typically used as shown in the example below.

       FILE * f = fopen("test.mtx", "r");
       /* ... Handle errors ... */

       struct mtx mtx;
       int line, column;
       int err = mtx_fread(&mtx, f, &line, &column);
       if (err) {
           fprintf(stderr, "Error: test.mtx:%d:%d: %s\n",
                   line, column, mtx_strerror(err));
           fclose(f);
       }

   If libmtx is built with MPI support enabled, then there are
some functions in libmtx that may fail due to MPI errors.  In
these cases, some additional information is needed to provide helpful
error descriptions, and the function 'mtx_strerror_mpi' should be used.
     const char * mtx_strerror_mpi(
         int err,
         int mpierrcode,
         char * mpierrstr);
   The error code 'err' is an integer corresponding to one of the error
codes from the 'mtx_error' enum type.  The arguments 'mpierrcode' and
'mpierrstr' are only used if 'err' is 'MTX_ERR_MPI'.

   If 'err' is 'MTX_ERR_MPI', then the argument 'mpierrcode' should be
set to the error code that was returned from the MPI function call that
failed.  In addition, the argument 'mpierrstr' must be a char array
whose length is at least equal to 'MPI_MAX_ERROR_STRING'.  Internally,
'mtx_strerror_mpi' uses 'MPI_Error_string' to obtain a description of
the error.


File: libmtx.info,  Node: Reading and writing Matrix Market files,  Next: Creating matrices and vectors,  Prev: Error handling,  Up: Matrix Market objects

5.3 Reading and writing Matrix Market files
===========================================

The file 'libmtx/mtx/io.h' defines functions for reading from and
writing to files in Matrix Market format.  These files are typically
named with a '.mtx' extension, so we refer to them here as 'mtx' files.

   To read an 'mtx' file from a 'FILE' stream, use the function:
     int mtx_fread(
         struct mtx * mtx,
         FILE * f,
         int * line_number,
         int * column_number);
   If successful, 'MTX_SUCCESS' is returned, and 'mtx' will contain the
matrix or vector represented by the 'FILE' stream.  The user is
responsible for calling 'mtx_free' to free any storage that may have
been allocated by 'mtx_fread'.  Otherwise, if 'mtx_fread' fails, then it
will return an error code, and 'line_number' and 'column_number' will
indicate the location in the Matrix Market file at which an error was
encountered.

   To write an 'mtx' file to a 'FILE' stream, use the function:
     int mtx_fwrite(
         const struct mtx * mtx,
         FILE * f,
         int field_width,
         int precision);
   If successful, 'MTX_SUCCESS' is returned, and 'mtx' is written to the
stream 'f'.  The argument 'field_width' can be used to set a field width
for printing numerical values to the 'FILE' stream, which causes numbers
to be padded on the left with spaces to ensure that a minimum of
'field_width' characters are printed.  The 'precision' argument can be
used to control the number of decimal places to use when printing
floating-point numerical values.  Note that 'precision' can be set to
'-1' to use a default precision, which is 6 digits after the decimal
point.

   If libmtx is built with zlib support, then the functions
'mtx_gzread' and 'mtx_gzwrite' can be used to read or write
gzip-compressed 'mtx' files.  The function signatures are the similar
'mtx_fread' and 'mtx_fwrite':
     int mtx_gzread(
         struct mtx * mtx,
         gzFile f,
         int * line_number,
         int * column_number);

     int mtx_gzwrite(
         const struct mtx * mtx,
         gzFile f,
         int field_width,
         int precision);


File: libmtx.info,  Node: Creating matrices and vectors,  Next: Matrix operations,  Prev: Reading and writing Matrix Market files,  Up: Matrix Market objects

5.4 Creating matrices and vectors
=================================

A number of functions are provided to more conveniently construct
matrices and vectors in the Matrix Market format.  These are described
in the following subsections.

   First, it is important to note that the matrix and vector creation
routines will allocate their own storage and copy the matrix or vector
data that the user provides.  As a result, once the user is finished
with a Matrix Market object, it is important to free allocated storage
by calling 'mtx_free':
     void mtx_free(
         struct mtx * mtx);

* Menu:

* Creating sparse matrices::
* Creating dense matrices::
* Creating vectors::
* Copying matrices and vectors::


File: libmtx.info,  Node: Creating sparse matrices,  Next: Creating dense matrices,  Up: Creating matrices and vectors

5.4.1 Creating sparse matrices
------------------------------

The file 'libmtx/matrix/coordinate/coordinate.h' defines functions for
constructing sparse matrices in the coordinate format.  For example, a
sparse matrix with real, single-precision floating point coefficients is
created with the function:
     int mtx_init_matrix_coordinate_real(
         struct mtx * mtx,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         enum mtx_ordering ordering,
         enum mtx_assembly assembly,
         int num_comment_lines,
         const char ** comment_lines,
         int num_rows,
         int num_columns,
         int64_t size,
         const struct mtx_matrix_coordinate_real * data);
   The sparse matrix will be stored in the Matrix Market object 'mtx',
which will have 'object', 'format' and 'field' set to 'mtx_matrix',
'mtx_coordinate' and 'mtx_real', respectively.  The symmetry of the
matrix is specified with 'symmetry', and the fields that make up the
additional header information can be provided by the arguments
'sorting', 'ordering' and 'assembly'.  In addition, 'comment_lines' is
an array of 'num_comment_lines' null-terminated strings, which will be
copied to the newly constructed matrix.

   The size of the matrix is specified with 'num_rows' and
'num_columns', and the number of explicitly stored nonzeros is given by
'size'.  The array 'data' must contain 'size' values of type 'struct
mtx_matrix_coordinate_real'.

   Recall that the data types for sparse matrices corresponding to the
different Matrix Market fields were described in *note Data::.  In the
case of a real matrix with values in single-precision floating point,
the appropriate data type is:
     struct mtx_matrix_coordinate_real {
         int i, j; /* row and column index */
         float a;  /* nonzero value */
     };

   Similar functions are provided for creating sparse matrices with
values from other fields.


File: libmtx.info,  Node: Creating dense matrices,  Next: Creating vectors,  Prev: Creating sparse matrices,  Up: Creating matrices and vectors

5.4.2 Creating dense matrices
-----------------------------

The file 'libmtx/matrix/array/array.h' defines functions for
constructing dense matrices.  For example, a dense m-by-n real matrix is
created with the function:
     int mtx_init_matrix_array_real(
         struct mtx * mtx,
         int num_comment_lines,
         const char ** comment_lines,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         int num_rows,
         int num_columns,
         const float * data);
   Here, 'mtx' is a pointer to an 'mtx' object that will contain the
dense matrix in Matrix Market format.  Comment lines are specified with
the arguments 'num_comment_lines' and 'comment_lines', where the latter
is an array of null-terminated strings that will be copied when
constructing the matrix.  The argument 'symmetry' is used to specify
symmetry properties of the matrix, and 'sorting' is either
'mtx_row_major' for a row-major ordering of the matrix entries, or
'mtx_column_major' otherwise.  Finally, the number of rows and columns
are set with 'num_rows' and 'num_columns', and the matrix entries are
given as an array, 'data', of 'num_rows*num_columns' values of type
'float'.

   Similar functions are provided for 'double', 'complex' and 'integer'
matrices.


File: libmtx.info,  Node: Creating vectors,  Next: Copying matrices and vectors,  Prev: Creating dense matrices,  Up: Creating matrices and vectors

5.4.3 Creating vectors
----------------------

The following functions can be used to conveniently create dense vectors
with real, single- or double precision floating point values, complex
single-precision floating point values, or integer values.
     int mtx_init_vector_array_real(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const float * data);

     int mtx_init_vector_array_double(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const double * data);

     int mtx_init_vector_array_complex(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const float * data);

     int mtx_init_vector_array_integer(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const int * data);


File: libmtx.info,  Node: Copying matrices and vectors,  Prev: Creating vectors,  Up: Creating matrices and vectors

5.4.4 Copying matrices and vectors
----------------------------------

The function 'mtx_copy' can be used to make a copy of an existing matrix
or vector:
     int mtx_copy(
         struct mtx * destmtx,
         const struct mtx * srcmtx);


File: libmtx.info,  Node: Matrix operations,  Next: Basic linear algebra operations,  Prev: Creating matrices and vectors,  Up: Matrix Market objects

5.5 Matrix operations
=====================

Sometimes, it is convenient to sort the nonzeros of a sparse matrix or
vector in the coordinate format.  This can be achieved with the function
'mtx_sort':
     int mtx_sort(
         struct mtx * mtx,
         struct mtx_sorting sorting);
   If successful, 'mtx_sort' returns 'MTX_SUCCESS', and 'mtx' will have
its nonzeros sorted according to the order specified by 'sorting'.  If
'mtx->format' is 'mtx_array', then 'mtx_sort' does nothing.

   The function 'mtx_matrix_transpose' can be used to transpose a square
matrix represented by a 'struct mtx' object.
     int mtx_matrix_transpose(
         struct mtx * mtx);
   The matrix is transposed in-place.  This currently only works for
matrices where 'format' is 'mtx_coordinate' and 'symmetry' is either
'general' or 'symmetric'.

   The function 'mtx_matrix_submatrix' can be used to obtain a submatrix
of a 'struct mtx' object, which consists of the nonzero entries from a
given set of rows and columns.
     int mtx_matrix_submatrix(
         const struct mtx * mtx,
         const struct mtx_index_set * rows,
         const struct mtx_index_set * columns,
         struct mtx * submatrix);
   Note that 'mtx_matrix_submatrix' currently only works for 'struct
mtx' objects where 'format' is 'mtx_coordinate'.


File: libmtx.info,  Node: Basic linear algebra operations,  Next: Communicating matrices and vectors,  Prev: Matrix operations,  Up: Matrix Market objects

5.6 Basic linear algebra operations
===================================

The libmtx C library implements a subset of the Basic Linear
Algebra Subprograms (BLAS) routines.  For dense operations,
libmtx relies on optimised, third-party BLAS libraries, such as
OpenBLAS (<https://www.openblas.net/>).  Otherwise, libmtx uses
internal routines for sparse matrix operations.

   The BLAS functions for 'mtx' vectors and matrices are defined in the
file 'libmtx/blas.h'.

* Menu:

* Level 1 BLAS operations::
* Level 2 BLAS operations::
* Level 3 BLAS operations::


File: libmtx.info,  Node: Level 1 BLAS operations,  Next: Level 2 BLAS operations,  Up: Basic linear algebra operations

5.6.1 Level 1 BLAS operations
-----------------------------

The following Level 1 BLAS operations are supported:
   * 'scal' -- 'x = a*x'
   * 'axpy' -- 'y = a*x + y'
   * 'dot' -- dot product
   * 'nrm2' -- Euclidean norm
   The corresponding function signatures are:
     int mtx_sscal(
         float a,
         struct mtx * x);

     int mtx_dscal(
         double a,
         struct mtx * x);

     int mtx_saxpy(
         float a,
         const struct mtx * x,
         struct mtx * y);

     int mtx_daxpy(
         double a,
         const struct mtx * x,
         struct mtx * y);

     int mtx_sdot(
         const struct mtx * x,
         const struct mtx * y,
         float * dot);

     int mtx_ddot(
         const struct mtx * x,
         const struct mtx * y,
         double * dot);

     int mtx_snrm2(
         const struct mtx * x,
         const struct mtx * y,
         float * nrm2);

     int mtx_dnrm2(
         const struct mtx * x,
         const struct mtx * y,
         double * nrm2);


File: libmtx.info,  Node: Level 2 BLAS operations,  Next: Level 3 BLAS operations,  Prev: Level 1 BLAS operations,  Up: Basic linear algebra operations

5.6.2 Level 2 BLAS operations
-----------------------------

The following Level 2 BLAS operations are supported:
   * 'gemv' -- matrix-vector multiply, 'y = alpha*A*x + beta*y'

   The corresponding function signatures are:
     int mtx_sgemv(
         float alpha,
         const struct mtx * A,
         const struct mtx * x,
         float beta,
         struct mtx * y);

     int mtx_dgemv(
         double alpha,
         const struct mtx * A,
         const struct mtx * x,
         double beta,
         struct mtx * y);


File: libmtx.info,  Node: Level 3 BLAS operations,  Prev: Level 2 BLAS operations,  Up: Basic linear algebra operations

5.6.3 Level 3 BLAS operations
-----------------------------

The following Level 3 BLAS operations are supported:
   * 'gemm' -- matrix-matrix multiply


File: libmtx.info,  Node: Communicating matrices and vectors,  Prev: Basic linear algebra operations,  Up: Matrix Market objects

5.7 Communicating matrices and vectors
======================================

The file 'libmtx/mtx/mpi.h' defines functions that can be used to
communicate Matrix Market objects represented by the 'mtx' struct
between MPI processes.

* Menu:

* MPI errors::
* send receive broadcast::
* Index sets::


File: libmtx.info,  Node: MPI errors,  Next: send receive broadcast,  Up: Communicating matrices and vectors

5.7.1 MPI errors
----------------

In the event of an MPI-related error, then the above functions return
'MTX_ERR_MPI' and the argument 'mpierrcode' is set to a specific MPI
error code.  'mpierrcode' can then be used with the function
'mtx_strerror_mpi', as described in *note Error handling::.


File: libmtx.info,  Node: send receive broadcast,  Next: Index sets,  Prev: MPI errors,  Up: Communicating matrices and vectors

5.7.2 Send, receive and broadcast
---------------------------------

The basic functions for communicating 'struct mtx' objects are:
     int mtx_send(
         const struct mtx * mtx,
         int dest,
         int tag,
         MPI_Comm comm,
         int * mpierrcode);

     int mtx_recv(
         struct mtx * mtx,
         int source,
         int tag,
         MPI_Comm comm,
         int * mpierrcode);

     int mtx_bcast(
         struct mtx * mtx,
         int root,
         MPI_Comm comm,
         int * mpierrcode);
   These functions are analogous to 'MPI_Send', 'MPI_Recv' and
'MPI_Bcast'.


File: libmtx.info,  Node: Index sets,  Prev: send receive broadcast,  Up: Communicating matrices and vectors

5.7.3 Index sets
----------------

An "index set" is a set of integers, typically used to represent a
subset of the rows of a vector or the rows or columns of a matrix.
Index sets are used, for example, when specifying submatrices of a
matrix, or for partitioning and distributing matrices and vectors among
multiple processes.

   The file 'libmtx/index_set.h' defines data types for index
sets, including 'struct mtx_index_set'.  There are different types of
index sets, which may be distinguished by the enum type
'mtx_index_set_type'.
   * 'mtx_index_set_interval' represents an index set of contiguous
     integers from a half-open interval '[a,b)'.

   * 'mtx_index_set_array' represents a discrete index set, which is not
     necessarily contiguous, as an array of integers.

   An index set representing a half-open interval '[a,b)' can be created
with 'mtx_index_set_init_interval'.
     int mtx_index_set_init_interval(
         struct mtx_index_set * index_set, int a, int b);
   Then, the function 'mtx_index_set_contains' can be used to test if a
given integer 'n' belongs to the index set.
     bool mtx_index_set_contains(
         const struct mtx_index_set * index_set, int n);

5.7.4 Gather and scatter
------------------------

Suppose each process in a group of MPI processes posesses some part of a
distributed sparse (coordinate) matrix.  Then the function
'mtx_matrix_coordinate_gather' can be used to gather the matrices from
each MPI process to form a single matrix on one of the MPI processes,
which is designated as the root process.
     int mtx_matrix_coordinate_gather(
         struct mtx * dstmtx,
         const struct mtx * srcmtx,
         enum mtx_partitioning partitioning,
         MPI_Comm comm,
         int root,
         int * mpierrcode);
   Here, 'dstmtx' is the gathered matrix on the root process, whereas
'srcmtx' is the part of the matrix owned by each MPI process.  The MPI
communicator is given by 'comm', and the integer 'root' is the rank of
the MPI root process onto which the matrix is gathered.  The MPI process
with rank equal to 'root' must belong to the MPI communicator 'comm'.

   If each of the matrices to gather data from is in an assembled state,
that is, 'assembly' is 'mtx_assembled', and 'partitioning' is equal to
'mtx_partition', then the final, gathered matrix is considered to be in
an assembled state.  Otherwise, the gathered matrix is unassembled.

   Conversely, a sparse matrix can also be distributed from a single MPI
root process to a group of MPI processes using
'mtx_matrix_coordinate_scatter'.
     int mtx_matrix_coordinate_scatter(
         struct mtx * dstmtx,
         const struct mtx * srcmtx,
         const struct mtx_index_set * rows,
         const struct mtx_index_set * columns,
         MPI_Comm comm,
         int root,
         int * mpierrcode);
   Here, 'srcmtx' is the original matrix on the MPI root process,
whereas, on each MPI process, 'dstmtx' is the part of the matrix owned
by the current MPI process.  Furthermore, 'rows' and 'columns' are index
sets that determine the global rows and columns that will be scattered
to the current MPI process.  The matrix is distributed among MPI
processes belonging to the communicator 'comm', and the 'root' argument
is the MPI rank of the root process which owns 'dstmtx'.


File: libmtx.info,  Node: Commands,  Next: C library reference,  Prev: Matrix Market objects,  Up: Top

6 Commands
**********

This section contains a list of command-line programs provided by
libmtx for working with Matrix Market files.

'mtxinfo'
     reads a Matrix Market file, validates the contents and displays
     some high-level information about the Matrix Market object.

'mtxgemv'
     multiplies a general, unsymmetric matrix by a vector.

'mtxsort'
     sorts the entries of a dense or sparse matrix, for example, in row-
     or column-major order.

'mtxreorder'
     reorders the nonzeros of a sparse matrix, for example, using the
     Reverse Cuthill-McKee (RCM) ordering (*note E. Cuthill and J. McKee
     (1969)::).

'mtxscatter'
     distributes a Matrix Market file among MPI processes and stores the
     resulting distributed Matrix Market file for each process.

'mtxgather'
     collects Matrix Market files that represent a distributed matrix or
     vector from multiple MPI processes, accumulates the results on a
     single MPI root process and stores the resulting Matrix Market
     file.

   Further details about each program are given in the following
sections.

* Menu:

* mtxinfo::
* mtxgemv::
* mtxsort::
* mtxreorder::
* mtxscatter::
* mtxgather::


File: libmtx.info,  Node: mtxinfo,  Next: mtxgemv,  Up: Commands

6.1 'mtxinfo'
=============

The command 'mtxinfo' reads a Matrix Market file, validates the contents
and displays some high-level information about the Matrix Market object.
     mtxinfo [OPTION..] FILE

   The following options are accepted:
'-z, --gzip, --gunzip, --ungzip'
     Filter the file through gzip.

'-v, --verbose'
     Print diagnostics to standard error.


File: libmtx.info,  Node: mtxgemv,  Next: mtxsort,  Prev: mtxinfo,  Up: Commands

6.2 'mtxgemv'
=============

The command 'mtxgemv' is used to multiply a general, unsymmetric matrix
with a vector.  The result is written to standard output in the form of
a Matrix Market file representing the result vector.  More specifically,
the calculation carried out is 'Y := ALPHA*A*X + BETA*Y'.

   The 'mtxgemv' command accepts a number of positional arguments
corresponding to the variables in the matrix-vector multiplication:
     mtxgemv [OPTION..] ALPHA A [X] [BETA] [Y]

   The positional arguments are:
'ALPHA'
     The scalar floating-point value 'ALPHA'.

'A'
     Path to a Matrix Market file containing the matrix 'A'.

'X'
     Path to a Matrix Market file containing the vector 'X'.  If this
     argument is omitted or an empty string (i.e., '""'), then a vector
     of ones of length equal to the number of columns of 'A' is used.

'BETA'
     The scalar floating-point value 'BETA'.  If this argument is
     omitted, then 'BETA' is set equal to one.

'Y'
     Path to a Matrix Market file containing the vector 'Y'.  If this
     argument is omitted, then a vector of zeros of length equal to the
     number of rows of 'A' is used.

   In addition, the following options are accepted:

'-z, --gzip, --gunzip, --ungzip'
     Filter files through gzip.

'--output-width=N'
     The field width to use when outputting numerical values in Matrix
     Market files.

'--output-prec=N'
     The number of digits of precision to use when outputting numerical
     values in Matrix Market files.  The default is to use 6 digits
     after the decimal place.

'--repeat=N'
     The number of times to repeat the matrix-vector multiplication.

'-q, --quiet'
     Do not print the resulting Matrix Market file to standard output.

'-v, --verbose'
     Print some diagnostics to the standard error stream.


File: libmtx.info,  Node: mtxsort,  Next: mtxreorder,  Prev: mtxgemv,  Up: Commands

6.3 'mtxsort'
=============

The command 'mtxsort' is used to sort the entries of a dense or sparse
matrix, for example, in row- or column-major order.
     mtxsort [OPTION..] FILE

   The following options are accepted:

'-z, --gzip, --gunzip, --ungzip'
     Filter the file through gzip.

'--output-width=N'
     The field width to use when outputting numerical values in Matrix
     Market files.

'--output-prec=N'
     The number of digits of precision to use when outputting numerical
     values in Matrix Market files.  The default is to use 6 digits
     after the decimal place.

'--sorting=SORTING'
     The ordering to use when sorting the data.  This is either
     'row-major' or 'column-major'.  By default, 'row-major' is used.

'-q, --quiet'
     Do not print the resulting Matrix Market file to standard output.

'-v, --verbose'
     Print diagnostics to standard error.


File: libmtx.info,  Node: mtxreorder,  Next: mtxscatter,  Prev: mtxsort,  Up: Commands

6.4 'mtxreorder'
================

The command 'mtxreorder' is used to reorder the nonzeros of a sparse
matrix, for example, using the Reverse Cuthill-McKee (RCM) ordering
(*note E. Cuthill and J. McKee (1969)::).

   This command is not yet implemented.


File: libmtx.info,  Node: mtxscatter,  Next: mtxgather,  Prev: mtxreorder,  Up: Commands

6.5 'mtxscatter'
================

The command 'mtxscatter' distributes a Matrix Market file among MPI
processes and stores the resulting distributed Matrix Market file for
each process.  This command is only included if MPI support is enabled.
     mtxscatter [OPTION..] FILE

   The following options are accepted:

'-z, --gzip, --gunzip, --ungzip'
     Filter files through gzip.

'--output-path=FILE'
     Output path for the scattered Matrix Market files, where '%p' in
     the string is replaced with the rank of each MPI process.  If not
     specified, the default output path is 'out%p.mtx'.

'--output-width=N'
     The field width to use when outputting numerical values in Matrix
     Market files.

'--output-prec=N'
     The number of digits of precision to use when outputting numerical
     values in Matrix Market files.  The default is to use 6 digits
     after the decimal place.

'-v, --verbose'
     Print diagnostics to standard error.


File: libmtx.info,  Node: mtxgather,  Prev: mtxscatter,  Up: Commands

6.6 'mtxgather'
===============

The command 'mtxgather' collects Matrix Market files that represent a
distributed matrix or vector from multiple MPI processes, accumulates
the results on a single MPI root process and stores the resulting Matrix
Market file.  This command is only included if MPI support is enabled.
     mtxgather [OPTION..] FILE..

   The following options are accepted:

'-z, --gzip, --gunzip, --ungzip'
     Filter files through gzip.

'--output-width=N'
     The field width to use when outputting numerical values in Matrix
     Market files.

'--output-prec=N'
     The number of digits of precision to use when outputting numerical
     values in Matrix Market files.  The default is to use 6 digits
     after the decimal place.

'-q, --quiet'
     Do not print the resulting Matrix Market file to standard output.

'-v, --verbose'
     Print diagnostics to standard error.


File: libmtx.info,  Node: C library reference,  Next: References,  Prev: Commands,  Up: Top

7 C library reference
*********************

This chapter is provided as a reference for the libmtx C
library.

7.1 Error handling
==================

     enum mtx_error
     {
       MTX_SUCCESS = 0,                    /* no error */
       MTX_ERR_ERRNO = -1,                 /* error code provided by errno */
       MTX_ERR_MPI = -2,                   /* MPI error */
       MTX_ERR_EOF = -3,                   /* unexpected end-of-file */
       MTX_ERR_LINE_TOO_LONG = -4,         /* line exceeds maximum length */
       MTX_ERR_INVALID_MTX_HEADER = -5,    /* invalid mtx header */
       MTX_ERR_INVALID_MTX_OBJECT = -6,    /* invalid mtx object */
       MTX_ERR_INVALID_MTX_FORMAT = -7,    /* invalid mtx format */
       MTX_ERR_INVALID_MTX_FIELD = -8,     /* invalid mtx field */
       MTX_ERR_INVALID_MTX_SYMMETRY = -9,  /* invalid mtx symmetry */
       MTX_ERR_INVALID_MTX_SORTING = -10,  /* invalid mtx sorting */
       MTX_ERR_INVALID_MTX_ORDERING = -11, /* invalid mtx ordering */
       MTX_ERR_INVALID_MTX_ASSEMBLY = -12, /* invalid mtx assembly */
       MTX_ERR_INVALID_MTX_SIZE = -13,     /* invalid mtx size info */
       MTX_ERR_INVALID_MTX_DATA = -14,     /* invalid mtx data */
     };

     const char * mtx_strerror(int err);

     const char * mtx_strerror_mpi(
         int err,
         int mpierrcode,
         char * mpierrstr);

7.2 Header information
======================

     enum mtx_object {
         mtx_matrix,
         mtx_vector
     };

     enum mtx_format {
         mtx_array,     /* array of dense matrix values */
         mtx_coordinate /* coordinate format of sparse matrix values */
     };

     enum mtx_field {
         mtx_real,    /* single-precision floating point coefficients */
         mtx_double,  /* double-precision floating point coefficients */
         mtx_complex, /* single-precision floating point complex
                       * coefficients */
         mtx_integer, /* integer coefficients */
         mtx_pattern  /* boolean coefficients (sparsity pattern) */
     };

     enum mtx_symmetry {
         mtx_general,        /* general, non-symmetric matrix */
         mtx_symmetric,      /* symmetric matrix */
         mtx_skew_symmetric, /* skew-symmetric matrix */
         mtx_hermitian       /* Hermitian matrix */
     };

7.2.1 Additional header information
-----------------------------------

     enum mtx_sorting {
         mtx_unsorted,       /* unsorted matrix nonzeros */
         mtx_row_major,      /* row major ordering */
         mtx_column_major,   /* column major ordering */
     };

     enum mtx_ordering {
         mtx_unordered,      /* general, unordered matrix */
         mtx_rcm,            /* Reverse Cuthill-McKee ordering */
     };

     enum mtx_assembly {
         mtx_unassembled, /* unassembled; duplicate nonzeros allowed. */
         mtx_assembled,   /* assembled; duplicate nonzeros not allowed. */
     };

     enum mtx_partitioning {
         mtx_partition,   /* matrix/vector entries are owned
                           * by a single MPI process. */
         mtx_cover,       /* matrix/vector entries may be shared
                           * by multiple MPI processes. */
     };

7.3 Sparse matrix and vector data types
=======================================

     /*
      * Sparse matrix data types.
      */
     struct mtx_matrix_coordinate_real {
         int i, j; /* row and column index */
         float a;  /* nonzero value */
     };

     struct mtx_matrix_coordinate_double {
         int i, j; /* row and column index */
         double a; /* nonzero value */
     };

     struct mtx_matrix_coordinate_complex {
         int i, j;     /* row and column index */
         float a, b;   /* real and imaginary parts of nonzero value */
     };

     struct mtx_matrix_coordinate_integer {
         int i, j; /* row and column index */
         int a;    /* nonzero value */
     };

     struct mtx_matrix_coordinate_pattern {
         int i, j; /* row and column index */
     };

     /*
      * Sparse vector data types.
      */

     struct mtx_vector_coordinate_real {
         int i;    /* row index */
         float a;  /* nonzero value */
     };

     struct mtx_vector_coordinate_double {
         int i;    /* row index */
         double a; /* nonzero value */
     };

     struct mtx_vector_coordinate_complex {
         int i;        /* row index */
         float a, b;   /* real and imaginary parts of nonzero value */
     };

     struct mtx_vector_coordinate_integer {
         int i;    /* row index */
         int a;    /* nonzero value */
     };

     struct mtx_vector_coordinate_pattern {
         int i; /* row index */
     };

7.4 Matrix Market data type
===========================

     struct mtx {
       /* Header */
       enum mtx_object object;
       enum mtx_format format;
       enum mtx_field field;
       enum mtx_symmetry symmetry;

       /* Extra header info */
       enum mtx_sorting sorting;
       enum mtx_ordering ordering;
       enum mtx_assembly assembly;

       /* Comments */
       int num_comment_lines;
       char ** comment_lines;

       /* Size */
       int num_rows;
       int num_columns;
       int64_t num_nonzeros;
       int64_t size;
       int64_t nonzero_size;

       /* Data */
       void * data;
     };

7.4.1 Memory management
-----------------------

     void mtx_free(
         struct mtx * mtx);

     int mtx_copy(
         struct mtx * destmtx,
         const struct mtx * srcmtx);

7.4.2 I/O
---------

     int mtx_fread(
         struct mtx * mtx,
         FILE * f,
         int * line_number,
         int * column_number);

     int mtx_fwrite(
         const struct mtx * mtx,
         FILE * f,
         int field_width,
         int precision);

     int mtx_gzread(
         struct mtx * mtx,
         gzFile f,
         int * line_number,
         int * column_number);

     int mtx_gzwrite(
         const struct mtx * mtx,
         gzFile f,
         int field_width,
         int precision);

7.4.3 Sparse matrices
---------------------

     int mtx_init_matrix_coordinate_real(
         struct mtx * mtx,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         enum mtx_ordering ordering,
         enum mtx_assembly assembly,
         int num_comment_lines,
         const char ** comment_lines,
         int num_rows,
         int num_columns,
         int64_t size,
         const struct mtx_matrix_coordinate_real * data);

     int mtx_init_matrix_coordinate_double(
         struct mtx * matrix,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         enum mtx_ordering ordering,
         enum mtx_assembly assembly,
         int num_comment_lines,
         const char ** comment_lines,
         int num_rows,
         int num_columns,
         int64_t size,
         const struct mtx_matrix_coordinate_double * data);

     int mtx_init_matrix_coordinate_complex(
         struct mtx * matrix,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         enum mtx_ordering ordering,
         enum mtx_assembly assembly,
         int num_comment_lines,
         const char ** comment_lines,
         int num_rows,
         int num_columns,
         int64_t size,
         const struct mtx_matrix_coordinate_complex * data);

     int mtx_init_matrix_coordinate_integer(
         struct mtx * matrix,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         enum mtx_ordering ordering,
         enum mtx_assembly assembly,
         int num_comment_lines,
         const char ** comment_lines,
         int num_rows,
         int num_columns,
         int64_t size,
         const struct mtx_matrix_coordinate_integer * data);

     int mtx_init_matrix_coordinate_pattern(
         struct mtx * matrix,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         enum mtx_ordering ordering,
         enum mtx_assembly assembly,
         int num_comment_lines,
         const char ** comment_lines,
         int num_rows,
         int num_columns,
         int64_t size,
         const struct mtx_matrix_coordinate_pattern * data);

7.4.4 Dense matrices
--------------------

     int mtx_init_matrix_array_real(
         struct mtx * mtx,
         int num_comment_lines,
         const char ** comment_lines,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         int num_rows,
         int num_columns,
         const float * data);

     int mtx_init_matrix_array_double(
         struct mtx * mtx,
         int num_comment_lines,
         const char ** comment_lines,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         int num_rows,
         int num_columns,
         const double * data);

     int mtx_init_matrix_array_complex(
         struct mtx * mtx,
         int num_comment_lines,
         const char ** comment_lines,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         int num_rows,
         int num_columns,
         const float * data);

     int mtx_init_matrix_array_integer(
         struct mtx * mtx,
         int num_comment_lines,
         const char ** comment_lines,
         enum mtx_symmetry symmetry,
         enum mtx_sorting sorting,
         int num_rows,
         int num_columns,
         const int * data);

7.4.5 Dense vectors
-------------------

     int mtx_init_vector_array_real(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const float * data);

     int mtx_init_vector_array_double(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const double * data);

     int mtx_init_vector_array_complex(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const float * data);

     int mtx_init_vector_array_integer(
         struct mtx * vector,
         int num_comment_lines,
         const char ** comment_lines,
         int size,
         const int * data);

7.5 Matrix and vector operations
================================

     int mtx_sort(
         struct mtx * mtx,
         struct mtx_sorting sorting);

     int mtx_matrix_transpose(
         struct mtx * mtx);

     int mtx_matrix_submatrix(
         const struct mtx * mtx,
         const struct mtx_index_set * rows,
         const struct mtx_index_set * columns,
         struct mtx * submatrix);

7.6 BLAS
========

7.6.1 Level 1 BLAS operations
-----------------------------

     int mtx_sscal(
         float a,
         struct mtx * x);

     int mtx_dscal(
         double a,
         struct mtx * x);

     int mtx_saxpy(
         float a,
         const struct mtx * x,
         struct mtx * y);

     int mtx_daxpy(
         double a,
         const struct mtx * x,
         struct mtx * y);

     int mtx_sdot(
         const struct mtx * x,
         const struct mtx * y,
         float * dot);

     int mtx_ddot(
         const struct mtx * x,
         const struct mtx * y,
         double * dot);

     int mtx_snrm2(
         const struct mtx * x,
         const struct mtx * y,
         float * nrm2);

     int mtx_dnrm2(
         const struct mtx * x,
         const struct mtx * y,
         double * nrm2);

7.6.2 Level 2 BLAS operations
-----------------------------

     int mtx_sgemv(
         float alpha,
         const struct mtx * A,
         const struct mtx * x,
         float beta,
         struct mtx * y);

     int mtx_dgemv(
         double alpha,
         const struct mtx * A,
         const struct mtx * x,
         double beta,
         struct mtx * y);

7.6.3 Level 3 BLAS operations
-----------------------------

7.7 MPI communication
=====================

7.7.1 Send, receive and broadcast
---------------------------------

     int mtx_send(
         const struct mtx * mtx,
         int dest,
         int tag,
         MPI_Comm comm,
         int * mpierrcode);

     int mtx_recv(
         struct mtx * mtx,
         int source,
         int tag,
         MPI_Comm comm,
         int * mpierrcode);

     int mtx_bcast(
         struct mtx * mtx,
         int root,
         MPI_Comm comm,
         int * mpierrcode);

7.7.2 Index sets
----------------

     int mtx_index_set_init_interval(
         struct mtx_index_set * index_set, int a, int b);

     bool mtx_index_set_contains(
         const struct mtx_index_set * index_set, int n);

7.7.3 Scatter and gather
------------------------

     int mtx_matrix_coordinate_gather(
         struct mtx * dstmtx,
         const struct mtx * srcmtx,
         enum mtx_partitioning partitioning,
         MPI_Comm comm,
         int root,
         int * mpierrcode);

     int mtx_matrix_coordinate_scatter(
         struct mtx * dstmtx,
         const struct mtx * srcmtx,
         const struct mtx_index_set * row_sets,
         const struct mtx_index_set * column_sets,
         MPI_Comm comm,
         int root,
         int * mpierrcode);


File: libmtx.info,  Node: References,  Next: GNU Free Documentation License,  Prev: C library reference,  Up: Top

References
**********

   * Ronald F. Boisvert, Roldan Pozo, and Karin Remington.  'The Matrix
     Market exchange formats: Initial design'.  Technical Report NISTIR
     5935, National Institute of Standards and Technology, Gaithersburg,
     MD, USA, December 1996.

   * National Institute of Standards and Technology (NIST). 'Matrix
     Market'.  Mathematical and Computational Sciences Division,
     Information Technology Laboratory, NIST, 10 May 2007.
     <https://math.nist.gov/MatrixMarket/index.html>.

   * National Institute of Standards and Technology (NIST). 'ANSI C
     library for Matrix Market I/O'. Mathematical and Computational
     Sciences Division, Information Technology Laboratory, NIST, 2 May
     2000.  <https://math.nist.gov/MatrixMarket/mmio-c.html>.

   * Tim Davis, Yifan Hu, and Scott Kolodziej.  'SuiteSparse Matrix
     Collection'.  Computer Science and Engineering Department, Texas
     A&M University.  <https://sparse.tamu.edu/>.

   * E. Cuthill and J. McKee.  'Reducing the bandwidth of sparse
     symmetric matrices'.  Proc.  24th Nat.  Conf.  ACM, pages 157–172,
     1969.

   * J. A. George and J. W-H. Liu, 'Computer Solution of Large Sparse
     Positive Definite Systems', Prentice-Hall, 1981.

   * Zhang Xianyi, 'OpenBLAS'. <https://www.openblas.net/>.


File: libmtx.info,  Node: GNU Free Documentation License,  Next: General index,  Prev: References,  Up: Top

Appendix A GNU Free Documentation License
*****************************************

                     Version 1.3, 3 November 2008

     Copyright (C) 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
     <http://fsf.org/>

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.  We
     recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it can
     be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You accept
     the license if you copy, modify or distribute the work in a way
     requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in the
     notice that says that the Document is released under this License.
     If a section does not fit the above definition of Secondary then it
     is not allowed to be designated as Invariant.  The Document may
     contain zero Invariant Sections.  If the Document does not identify
     any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images composed
     of pixels) generic paint programs or (for drawings) some widely
     available drawing editor, and that is suitable for input to text
     formatters or for automatic translation to a variety of formats
     suitable for input to text formatters.  A copy made in an otherwise
     Transparent file format whose markup, or absence of markup, has
     been arranged to thwart or discourage subsequent modification by
     readers is not Transparent.  An image format is not Transparent if
     used for any substantial amount of text.  A copy that is not
     "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and standard-conforming
     simple HTML, PostScript or PDF designed for human modification.
     Examples of transparent image formats include PNG, XCF and JPG.
     Opaque formats include proprietary formats that can be read and
     edited only by proprietary word processors, SGML or XML for which
     the DTD and/or processing tools are not generally available, and
     the machine-generated HTML, PostScript or PDF produced by some word
     processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     The "publisher" means any person or entity that distributes copies
     of the Document to the public.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow the
     conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the title
     equally prominent and visible.  You may add other material on the
     covers in addition.  Copying with changes limited to the covers, as
     long as they preserve the title of the Document and satisfy these
     conditions, can be treated as verbatim copying in other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a machine-readable
     Transparent copy along with each Opaque copy, or state in or with
     each Opaque copy a computer-network location from which the general
     network-using public has access to download using public-standard
     network protocols a complete Transparent copy of the Document, free
     of added material.  If you use the latter option, you must take
     reasonably prudent steps, when you begin distribution of Opaque
     copies in quantity, to ensure that this Transparent copy will
     remain thus accessible at the stated location until at least one
     year after the last time you distribute an Opaque copy (directly or
     through your agents or retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of copies,
     to give them a chance to provide you with an updated version of the
     Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with the
     Modified Version filling the role of the Document, thus licensing
     distribution and modification of the Modified Version to whoever
     possesses a copy of it.  In addition, you must do these things in
     the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of previous
          versions (which should, if there were any, be listed in the
          History section of the Document).  You may use the same title
          as a previous version if the original publisher of that
          version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on the
          Title Page.  If there is no section Entitled "History" in the
          Document, create one stating the title, year, authors, and
          publisher of the Document as given on its Title Page, then add
          an item describing the Modified Version as stated in the
          previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in the
          "History" section.  You may omit a network location for a work
          that was published at least four years before the Document
          itself, or if the original publisher of the version it refers
          to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the section
          all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document, unaltered
          in their text and in their titles.  Section numbers or the
          equivalent are not considered part of the section titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option designate
     some or all of these sections as invariant.  To do this, add their
     titles to the list of Invariant Sections in the Modified Version's
     license notice.  These titles must be distinct from any other
     section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end of
     the list of Cover Texts in the Modified Version.  Only one passage
     of Front-Cover Text and one of Back-Cover Text may be added by (or
     through arrangements made by) any one entity.  If the Document
     already includes a cover text for the same cover, previously added
     by you or by arrangement made by the same entity you are acting on
     behalf of, you may not add another; but you may replace the old
     one, on explicit permission from the previous publisher that added
     the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination all
     of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the documents
     in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow this
     License in all other respects regarding verbatim copying of that
     document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of a
     storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included in an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warranty Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense, or distribute it is void,
     and will automatically terminate your rights under this License.

     However, if you cease all violation of this License, then your
     license from a particular copyright holder is reinstated (a)
     provisionally, unless and until the copyright holder explicitly and
     finally terminates your license, and (b) permanently, if the
     copyright holder fails to notify you of the violation by some
     reasonable means prior to 60 days after the cessation.

     Moreover, your license from a particular copyright holder is
     reinstated permanently if the copyright holder notifies you of the
     violation by some reasonable means, this is the first time you have
     received notice of violation of this License (for any work) from
     that copyright holder, and you cure the violation prior to 30 days
     after your receipt of the notice.

     Termination of your rights under this section does not terminate
     the licenses of parties who have received copies or rights from you
     under this License.  If your rights have been terminated and not
     permanently reinstated, receipt of a copy of some or all of the
     same material does not give you any rights to use it.

  10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     <http://www.gnu.org/copyleft/>.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If the
     Document does not specify a version number of this License, you may
     choose any version ever published (not as a draft) by the Free
     Software Foundation.  If the Document specifies that a proxy can
     decide which future versions of this License can be used, that
     proxy's public statement of acceptance of a version permanently
     authorizes you to choose that version for the Document.

  11. RELICENSING

     "Massive Multiauthor Collaboration Site" (or "MMC Site") means any
     World Wide Web server that publishes copyrightable works and also
     provides prominent facilities for anybody to edit those works.  A
     public wiki that anybody can edit is an example of such a server.
     A "Massive Multiauthor Collaboration" (or "MMC") contained in the
     site means any set of copyrightable works thus published on the MMC
     site.

     "CC-BY-SA" means the Creative Commons Attribution-Share Alike 3.0
     license published by Creative Commons Corporation, a not-for-profit
     corporation with a principal place of business in San Francisco,
     California, as well as future copyleft versions of that license
     published by that same organization.

     "Incorporate" means to publish or republish a Document, in whole or
     in part, as part of another Document.

     An MMC is "eligible for relicensing" if it is licensed under this
     License, and if all works that were first published under this
     License somewhere other than this MMC, and subsequently
     incorporated in whole or in part into the MMC, (1) had no cover
     texts or invariant sections, and (2) were thus incorporated prior
     to November 1, 2008.

     The operator of an MMC Site may republish an MMC contained in the
     site under CC-BY-SA on the same site at any time before August 1,
     2009, provided the MMC is eligible for relicensing.

ADDENDUM: How to use this License for your documents
====================================================

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and license
notices just after the title page:

       Copyright (C)  YEAR  YOUR NAME.
       Permission is granted to copy, distribute and/or modify this document
       under the terms of the GNU Free Documentation License, Version 1.3
       or any later version published by the Free Software Foundation;
       with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
       Texts.  A copy of the license is included in the section entitled ``GNU
       Free Documentation License''.

   If you have Invariant Sections, Front-Cover Texts and Back-Cover
Texts, replace the "with...Texts." line with this:

         with the Invariant Sections being LIST THEIR TITLES, with
         the Front-Cover Texts being LIST, and with the Back-Cover Texts
         being LIST.

   If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

   If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of free
software license, such as the GNU General Public License, to permit
their use in free software.


File: libmtx.info,  Node: General index,  Next: Function index,  Prev: GNU Free Documentation License,  Up: Top

General index
*************

 [index ]
* Menu:

* array:                                 Header line.          (line 15)
* assembly:                              Additional header types.
                                                               (line 31)
* axpy:                                  Level 1 BLAS operations.
                                                               (line  6)
* BLAS:                                  Optional dependencies.
                                                               (line  6)
* bug reporting:                         Reporting Bugs.       (line  6)
* checklist for bug reports:             Reporting Bugs.       (line  9)
* column-major:                          Additional header types.
                                                               (line 11)
* comment lines:                         Comment lines.        (line  6)
* complex:                               Header line.          (line 18)
* complex <1>:                           Header line.          (line 26)
* coordinate:                            Header line.          (line 15)
* cover:                                 Additional header types.
                                                               (line 44)
* data line:                             Data lines.           (line  6)
* dense matrix:                          Size line.            (line 26)
* dense matrix <1>:                      Data lines.           (line 18)
* dense vector:                          Size line.            (line 10)
* dense vector <1>:                      Data lines.           (line 18)
* dot:                                   Level 1 BLAS operations.
                                                               (line  6)
* dot product:                           Level 1 BLAS operations.
                                                               (line  6)
* double:                                Header line.          (line 18)
* double <1>:                            Header line.          (line 26)
* Euclidean norm:                        Level 1 BLAS operations.
                                                               (line  6)
* gather:                                Index sets.           (line 34)
* gemm:                                  Level 3 BLAS operations.
                                                               (line  6)
* gemv:                                  Level 2 BLAS operations.
                                                               (line  6)
* header line:                           Header line.          (line  6)
* Hermitian:                             Header line.          (line 22)
* Hermitian <1>:                         Header line.          (line 47)
* Index set:                             Index sets.           (line  6)
* installing:                            Installing libmtx.
                                                               (line  6)
* integer:                               Header line.          (line 18)
* integer <1>:                           Header line.          (line 26)
* Matrix Market:                         Introduction to libmtx.
                                                               (line 25)
* Matrix Market, header line:            Header line.          (line  6)
* Matrix Market, identifier:             Header line.          (line  6)
* Matrix Market, object:                 Header line.          (line 12)
* Matrix Market, format:                 Header line.          (line 15)
* Matrix Market, field:                  Header line.          (line 18)
* Matrix Market, symmetry:               Header line.          (line 22)
* Matrix Market, field <1>:              Header line.          (line 26)
* Matrix Market, symmetry <1>:           Header line.          (line 47)
* Matrix Market, comment lines:          Comment lines.        (line  6)
* Matrix Market, size line:              Size line.            (line  6)
* Matrix Market, data lines:             Data lines.           (line  6)
* Matrix Market format:                  Introduction to libmtx.
                                                               (line 32)
* Matrix Market format <1>:              Matrix Market file format.
                                                               (line  8)
* Matrix Market format, header line:     Header line.          (line  6)
* Matrix Market format, object:          Header line.          (line 12)
* Matrix Market format, format:          Header line.          (line 15)
* Matrix Market format, field:           Header line.          (line 18)
* Matrix Market format, symmetry:        Header line.          (line 22)
* Matrix Market format, field <1>:       Header line.          (line 26)
* Matrix Market format, symmetry <1>:    Header line.          (line 47)
* Matrix Market format, comment lines:   Comment lines.        (line  6)
* Matrix Market format, size line:       Size line.            (line  6)
* Matrix Market format, data lines:      Data lines.           (line  6)
* Matrix Market I/O library for ANSI C:  Introduction to libmtx.
                                                               (line 25)
* matrix-matrix multiply:                Level 3 BLAS operations.
                                                               (line  6)
* matrix-vector multiply:                Level 2 BLAS operations.
                                                               (line  6)
* mmio:                                  Introduction to libmtx.
                                                               (line 25)
* MPI:                                   Optional dependencies.
                                                               (line  6)
* MPI errors:                            Error handling.       (line 48)
* MPI errors <1>:                        MPI errors.           (line  6)
* MPI_MAX_ERROR_STRING:                  Error handling.       (line 60)
* nrm2:                                  Level 1 BLAS operations.
                                                               (line  6)
* ordering:                              Additional header types.
                                                               (line 22)
* partition:                             Additional header types.
                                                               (line 44)
* patches, contributing:                 Reporting Bugs.       (line 26)
* pattern:                               Header line.          (line 18)
* pattern <1>:                           Header line.          (line 26)
* problems:                              Reporting Bugs.       (line  6)
* RCM:                                   Additional header types.
                                                               (line 22)
* real:                                  Header line.          (line 18)
* real <1>:                              Header line.          (line 26)
* reordering:                            Additional header types.
                                                               (line 22)
* reporting bugs:                        Reporting Bugs.       (line  6)
* Reverse Cuthill-McKee:                 Additional header types.
                                                               (line 22)
* row-major:                             Data lines.           (line 10)
* row-major <1>:                         Additional header types.
                                                               (line 11)
* scal:                                  Level 1 BLAS operations.
                                                               (line  6)
* scatter:                               Index sets.           (line 57)
* size line:                             Size line.            (line  6)
* skew-symmetric:                        Header line.          (line 22)
* skew-symmetric <1>:                    Header line.          (line 47)
* sorting:                               Additional header types.
                                                               (line 11)
* sorting <1>:                           Matrix operations.    (line  6)
* sparse matrix:                         Introduction to libmtx.
                                                               (line 12)
* sparse matrix <1>:                     Size line.            (line 33)
* sparse matrix <2>:                     Data lines.           (line 31)
* sparse matrix <3>:                     Data.                 (line 19)
* sparse vector:                         Size line.            (line 18)
* sparse vector <1>:                     Data lines.           (line 53)
* submatrix:                             Matrix operations.    (line 24)
* SuiteSparse Matrix Collection:         Introduction to libmtx.
                                                               (line 40)
* symmetric:                             Header line.          (line 22)
* symmetric <1>:                         Header line.          (line 47)
* symmetry:                              Header line.          (line 22)
* symmetry <1>:                          Header line.          (line 47)
* transpose:                             Matrix operations.    (line 16)
* unordered:                             Additional header types.
                                                               (line 22)
* unsymmetric:                           Header line.          (line 22)
* unsymmetric <1>:                       Header line.          (line 47)
* vector addition:                       Level 1 BLAS operations.
                                                               (line  6)
* vector scaling:                        Level 1 BLAS operations.
                                                               (line  6)
* zlib:                                  Optional dependencies.
                                                               (line  6)


File: libmtx.info,  Node: Function index,  Next: Data type index,  Prev: General index,  Up: Top

Function index
**************

 [index ]
* Menu:

* MPI_Error_string:                      Error handling.      (line  60)
* mtx_bcast:                             C library reference. (line 446)
* mtx_copy:                              Copying matrices and vectors.
                                                              (line   7)
* mtx_copy <1>:                          C library reference. (line 184)
* mtx_daxpy:                             Level 1 BLAS operations.
                                                              (line  11)
* mtx_daxpy <1>:                         C library reference. (line 382)
* mtx_ddot:                              Level 1 BLAS operations.
                                                              (line  11)
* mtx_ddot <1>:                          C library reference. (line 382)
* mtx_dgemm:                             C library reference. (line 439)
* mtx_dgemv:                             Level 2 BLAS operations.
                                                              (line   9)
* mtx_dgemv <1>:                         C library reference. (line 423)
* mtx_dnrm2:                             Level 1 BLAS operations.
                                                              (line  11)
* mtx_dnrm2 <1>:                         C library reference. (line 382)
* mtx_dscal:                             Level 1 BLAS operations.
                                                              (line  11)
* mtx_dscal <1>:                         C library reference. (line 382)
* mtx_free:                              Matrix Market data types.
                                                              (line  42)
* mtx_free <1>:                          Creating matrices and vectors.
                                                              (line  10)
* mtx_free <2>:                          C library reference. (line 184)
* mtx_gzread:                            Reading and writing Matrix Market files.
                                                              (line  40)
* mtx_gzread <1>:                        C library reference. (line 194)
* mtx_gzwrite:                           Reading and writing Matrix Market files.
                                                              (line  40)
* mtx_gzwrite <1>:                       C library reference. (line 194)
* mtx_index_set_contains:                Index sets.          (line  27)
* mtx_index_set_init_interval:           Index sets.          (line  23)
* mtx_index_set_init_interval <1>:       C library reference. (line 469)
* mtx_init_matrix_array_complex:         Creating dense matrices.
                                                              (line  30)
* mtx_init_matrix_array_complex <1>:     C library reference. (line 289)
* mtx_init_matrix_array_double:          Creating dense matrices.
                                                              (line  30)
* mtx_init_matrix_array_double <1>:      C library reference. (line 289)
* mtx_init_matrix_array_integer:         Creating dense matrices.
                                                              (line  30)
* mtx_init_matrix_array_integer <1>:     C library reference. (line 289)
* mtx_init_matrix_array_real:            Creating dense matrices.
                                                              (line   8)
* mtx_init_matrix_array_real <1>:        C library reference. (line 289)
* mtx_init_matrix_coordinate_complex:    Creating sparse matrices.
                                                              (line  45)
* mtx_init_matrix_coordinate_complex <1>: C library reference.
                                                              (line 221)
* mtx_init_matrix_coordinate_double:     Creating sparse matrices.
                                                              (line  45)
* mtx_init_matrix_coordinate_double <1>: C library reference. (line 221)
* mtx_init_matrix_coordinate_integer:    Creating sparse matrices.
                                                              (line  45)
* mtx_init_matrix_coordinate_integer <1>: C library reference.
                                                              (line 221)
* mtx_init_matrix_coordinate_pattern:    Creating sparse matrices.
                                                              (line  45)
* mtx_init_matrix_coordinate_pattern <1>: C library reference.
                                                              (line 221)
* mtx_init_matrix_coordinate_real:       Creating sparse matrices.
                                                              (line   9)
* mtx_init_matrix_coordinate_real <1>:   C library reference. (line 221)
* mtx_init_vector_array_complex:         Creating vectors.    (line   8)
* mtx_init_vector_array_complex <1>:     C library reference. (line 332)
* mtx_init_vector_array_double:          Creating vectors.    (line   8)
* mtx_init_vector_array_double <1>:      C library reference. (line 332)
* mtx_init_vector_array_integer:         Creating vectors.    (line   8)
* mtx_init_vector_array_integer <1>:     C library reference. (line 332)
* mtx_init_vector_array_real:            Creating vectors.    (line   8)
* mtx_init_vector_array_real <1>:        C library reference. (line 332)
* mtx_matrix_coordinate_gather:          Index sets.          (line  34)
* mtx_matrix_coordinate_gather <1>:      C library reference. (line 478)
* mtx_matrix_coordinate_scatter:         Index sets.          (line  57)
* mtx_matrix_coordinate_scatter <1>:     C library reference. (line 478)
* mtx_matrix_submatrix:                  Matrix operations.   (line  24)
* mtx_matrix_submatrix <1>:              C library reference. (line 363)
* mtx_matrix_transpose:                  Matrix operations.   (line  16)
* mtx_matrix_transpose <1>:              C library reference. (line 363)
* mtx_fread:                              Reading and writing Matrix Market files.
                                                              (line  10)
* mtx_fread <1>:                          C library reference. (line 194)
* mtx_recv:                              C library reference. (line 446)
* mtx_saxpy:                             Level 1 BLAS operations.
                                                              (line  11)
* mtx_saxpy <1>:                         C library reference. (line 382)
* mtx_sdot:                              Level 1 BLAS operations.
                                                              (line  11)
* mtx_sdot <1>:                          C library reference. (line 382)
* mtx_send:                              C library reference. (line 446)
* mtx_sgemm:                             C library reference. (line 440)
* mtx_sgemv:                             Level 2 BLAS operations.
                                                              (line   9)
* mtx_sgemv <1>:                         C library reference. (line 423)
* mtx_snrm2:                             Level 1 BLAS operations.
                                                              (line  11)
* mtx_snrm2 <1>:                         C library reference. (line 382)
* mtx_sort:                              Matrix operations.   (line   6)
* mtx_sort <1>:                          C library reference. (line 363)
* mtx_sscal:                             Level 1 BLAS operations.
                                                              (line  11)
* mtx_sscal <1>:                         C library reference. (line 382)
* mtx_strerror:                          Error handling.      (line  28)
* mtx_strerror <1>:                      C library reference. (line  31)
* mtx_strerror_mpi:                      Error handling.      (line  48)
* mtx_strerror_mpi <1>:                  MPI errors.          (line   6)
* mtx_strerror_mpi <2>:                  C library reference. (line  31)
* mtx_fwrite:                             Reading and writing Matrix Market files.
                                                              (line  24)
* mtx_fwrite <1>:                         C library reference. (line 194)


File: libmtx.info,  Node: Data type index,  Next: Program index,  Prev: Function index,  Up: Top

Data type index
***************

 [index ]
* Menu:

* enum mtx_index_set_type:               Index sets.          (line  12)
* enum mtx_index_set_type <1>:           C library reference. (line 469)
* mtx:                                   Matrix Market data types.
                                                              (line   9)
* mtx <1>:                               C library reference. (line 154)
* mtx_assembled:                         Additional header types.
                                                              (line  31)
* mtx_assembled <1>:                     C library reference. (line  70)
* mtx_assembly:                          Additional header types.
                                                              (line  31)
* mtx_assembly <1>:                      C library reference. (line  70)
* mtx_error:                             C library reference. (line  12)
* mtx_field:                             Header types.        (line   6)
* mtx_field <1>:                         C library reference. (line  41)
* mtx_format:                            Header types.        (line   6)
* mtx_format <1>:                        C library reference. (line  41)
* mtx_matrix_coordinate_complex:         Data.                (line  19)
* mtx_matrix_coordinate_complex <1>:     C library reference. (line  96)
* mtx_matrix_coordinate_double:          Data.                (line  19)
* mtx_matrix_coordinate_double <1>:      C library reference. (line  96)
* mtx_matrix_coordinate_integer:         Data.                (line  19)
* mtx_matrix_coordinate_integer <1>:     C library reference. (line  96)
* mtx_matrix_coordinate_pattern:         Data.                (line  19)
* mtx_matrix_coordinate_pattern <1>:     C library reference. (line  96)
* mtx_matrix_coordinate_real:            Data.                (line  19)
* mtx_matrix_coordinate_real <1>:        Creating sparse matrices.
                                                              (line  36)
* mtx_matrix_coordinate_real <2>:        C library reference. (line  96)
* mtx_object:                            Header types.        (line   6)
* mtx_object <1>:                        C library reference. (line  41)
* mtx_ordering:                          Additional header types.
                                                              (line  22)
* mtx_ordering <1>:                      C library reference. (line  70)
* mtx_partitioning:                      Additional header types.
                                                              (line  44)
* mtx_partitioning <1>:                  C library reference. (line  70)
* mtx_sorting:                           Additional header types.
                                                              (line  11)
* mtx_sorting <1>:                       C library reference. (line  70)
* mtx_symmetry:                          Header types.        (line   6)
* mtx_symmetry <1>:                      C library reference. (line  41)
* mtx_unassembled:                       Additional header types.
                                                              (line  31)
* mtx_unassembled <1>:                   C library reference. (line  70)
* mtx_vector_coordinate_complex:         Data.                (line  19)
* mtx_vector_coordinate_complex <1>:     C library reference. (line  96)
* mtx_vector_coordinate_double:          Data.                (line  19)
* mtx_vector_coordinate_double <1>:      C library reference. (line  96)
* mtx_vector_coordinate_integer:         Data.                (line  19)
* mtx_vector_coordinate_integer <1>:     C library reference. (line  96)
* mtx_vector_coordinate_pattern:         Data.                (line  19)
* mtx_vector_coordinate_pattern <1>:     C library reference. (line  96)
* mtx_vector_coordinate_real:            Data.                (line  19)
* mtx_vector_coordinate_real <1>:        C library reference. (line  96)
* struct mtx:                            Matrix Market data types.
                                                              (line   9)
* struct mtx <1>:                        C library reference. (line 154)
* struct mtx_index_set:                  Index sets.          (line  12)
* struct mtx_index_set <1>:              C library reference. (line 469)


File: libmtx.info,  Node: Program index,  Prev: Data type index,  Up: Top

Program index
*************

 [index ]
* Menu:

* mtxgather:                             Commands.             (line 29)
* mtxgather <1>:                         mtxgather.            (line  6)
* mtxgemv:                               Commands.             (line 13)
* mtxgemv <1>:                           mtxgemv.              (line  6)
* mtxinfo:                               Commands.             (line  9)
* mtxinfo <1>:                           mtxinfo.              (line  6)
* mtxreorder:                            Commands.             (line 20)
* mtxreorder <1>:                        mtxreorder.           (line  6)
* mtxscatter:                            Commands.             (line 25)
* mtxscatter <1>:                        mtxscatter.           (line  6)
* mtxsort:                               Commands.             (line 16)
* mtxsort <1>:                           mtxsort.              (line  6)



Tag Table:
Node: Top978
Node: Copying2624
Node: Introduction to libmtx3431
Node: Installing libmtx6140
Node: Optional dependencies6800
Node: Reporting Bugs7429
Node: Matrix Market file format8730
Node: Header line9954
Node: Comment lines13019
Node: Size line13478
Node: Data lines15218
Node: Matrix Market objects18200
Node: Matrix Market data types19243
Node: Header types20907
Node: Comments22120
Node: Size information22389
Node: Data24134
Node: Additional header types27093
Node: Error handling30119
Node: Reading and writing Matrix Market files33198
Node: Creating matrices and vectors35518
Node: Creating sparse matrices36399
Node: Creating dense matrices38469
Node: Creating vectors39906
Node: Copying matrices and vectors41070
Node: Matrix operations41441
Node: Basic linear algebra operations42917
Node: Level 1 BLAS operations43677
Node: Level 2 BLAS operations44829
Node: Level 3 BLAS operations45524
Node: Communicating matrices and vectors45809
Node: MPI errors46254
Node: send receive broadcast46671
Node: Index sets47419
Node: Commands50868
Node: mtxinfo52179
Node: mtxgemv52628
Node: mtxsort54545
Node: mtxreorder55531
Node: mtxscatter55886
Node: mtxgather56948
Node: C library reference57931
Node: References71182
Ref: R.F. Boisvert, R. Pozo and K. Remington (1996)71336
Ref: National Institute of Standards and Technology [NIST] (2007)71583
Ref: National Institute of Standards and Technology [NIST] (2000)71830
Ref: T. Davis, Y. Hu and S. Kolodziej (2021)72100
Ref: E. Cuthill and J. McKee (1969)72289
Ref: J.A. George and J. W-H. Liu (1981)72440
Ref: OpenBLAS72565
Node: GNU Free Documentation License72621
Node: General index97782
Node: Function index107913
Node: Data type index116120
Node: Program index120531

End Tag Table


Local Variables:
coding: utf-8
End:
