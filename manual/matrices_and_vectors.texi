@c This file is part of libmtx.
@c Copyright (C) 2022 James D. Trotter
@c
@c libmtx is free software: you can redistribute it and/or modify it
@c under the terms of the GNU General Public License as published by
@c the Free Software Foundation, either version 3 of the License, or
@c (at your option) any later version.
@c
@c libmtx is distributed in the hope that it will be useful, but
@c WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@c General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with libmtx.  If not, see <https://www.gnu.org/licenses/>.
@c
@c Authors: James D. Trotter <james@simula.no>
@c Last modified: 2022-01-04
@c
@c libmtx User Guide: Matrix Market objects.

@node Matrices and vectors
@chapter Matrices and vectors

This chapter provides a detailed explanation of how to work with
matrices and vectors using the libmtx C library.  For now, we are
concerned with matrices and vectors on a single, shared-memory machine
or node.  For matrices and vectors that are distributed across
multiple processes using MPI, see @ref{Distributed matrices and
vectors}.

For any user-facing types and functions, the library uses the
convention of prefixing their names with @code{mtx}. This makes it
easier to avoid possible name clashes with other code when using
libmtx.

@menu
* Error handling:: How to handle errors when working with the libmtx C library.
* Matrix Market files:: Basic data structure for representing Matrix Market objects.
* Reading and writing Matrix Market files:: Functions for reading from and writing to files in Matrix Market format.
* Creating matrices and vectors:: Functions for creating matrices and vectors.
* Transposing sorting and reordering:: Transposing, sorting and reordering matrices and vectors.
* Basic linear algebra operations:: Basic linear algebra
@end menu


@node Error handling
@section Error handling
Functions in the libmtx C library generally return a status code that
either indicates success (represented by the status code
@code{MTX_SUCCESS}) or a specific error.  Valid error codes correspond
to values of the type @code{enum mtxerror}, which is defined in the
file @file{libmtx/error.h} along with some error handling
functions.

@findex mtxstrerror
The function @code{mtxstrerror} can be used to give a string
containing a description of a given error code.
@example
@code{const char * mtxstrerror(int err);}
@end example
Here, the integer @code{err} should correspond to one of the error
codes from the @code{mtxerror} enum type.

@code{mtxstrerror} is typically used as shown in the example below.
@example
@code{FILE * f = fopen("test.mtx", "r");

struct mtxfile mtx;
int lines_read;
int err = mtxfile_fread(
    &mtx, mtx_double, f,
    &lines_read, NULL, 0, NULL);
if (err) @{
    fprintf(stderr, "Error: test.mtx:%d: %s\n",
            lines_read, mtxstrerror(err));
    fclose(f);
@}}
@end example
If @code{mtxfile_fread} returns @code{MTX_ERR_INVALID_MTX_OBJECT}, for
example, then the following message will be printed:
@example
@code{Error: test.mtx:1: invalid Matrix Market object}
@end example


@node Matrix Market files
@section Matrix Market files

This section describes the basic data types used to represent objects
in the Matrix Market file format.

@tindex struct mtxfile
@tindex mtxfile
The file @file{libmtx/mtxfile/mtxfile.h} defines the @code{struct
mtxfile} type.  The main purpose of @code{struct mtxfile} is to
represent objects in Matrix Market format, including dense and sparse
matrices and vectors with real, complex, integer or binary values. In
addition to @code{struct mtxfile}, libmtx also implements other data
structures to represent matrices and vectors with different underlying
storage formats.
@c These are described in @ref{...}.

The @code{mtxfile} struct is very close to the ASCII representation of
a Matrix Market file.  However, instead of ASCII strings, the header
values are converted to appropriate enum types.  The object size and
row and column indices are represented as 32-bit integers. Finally,
depending on the underlying field and desired precision, the matrix or
vector values are converted to 32- or 64-bit floating point numbers or
integers.

The definition of the @code{mtxfile} struct is shown below.
@example
@code{struct mtxfile @{
    struct mtxfileheader header;
    struct mtxfilecomments comments;
    struct mtxfilesize size;
    enum mtxprecision precision;
    union mtxfiledata data;
@};}
@end example

Roughly speaking, the @code{mtxfile} struct consists of four parts:
header information, comment lines, size information and data. In
addition, the @code{precision} struct member describes the precision
used to store matrix or vector values.

The following sections provide detailed explanations of the
@code{mtxfile} struct members.


@node Header
@subsection Header

The @code{mtxfileheader} data type is used to represent the header
line of a Matrix Market file.
@example
@code{struct mtxfileheader @{
    enum mtxfileobject object;
    enum mtxfileformat format;
    enum mtxfilefield field;
    enum mtxfilesymmetry symmetry;
@};}
@end example

@tindex mtxfileobject
@tindex mtxfileformat
@tindex mtxfilefield
@tindex mtxfilesymmetry
The four enum types, @code{mtxfileobject}, @code{mtxfileformat},
@code{mtxfilefield} and @code{mtxfilesymmetry} are used to represent values
that appear in the Matrix Market header (see @ref{Header line}).  The
meaning of the values associated with these types is described in
detail in @ref{Matrix Market file format}.
@example
@code{enum mtxfileobject @{
    mtxfile_matrix,
    mtxfile_vector
@};

enum mtxfileformat @{
    mtxfile_array,     /* dense matrix or vector */
    mtxfile_coordinate /* sparse matrix or vector */
@};

enum mtxfilefield @{
    mtxfile_real,    /* real, floating point coefficients */
    mtxfile_complex, /* complex, floating point coefficients */
    mtxfile_integer, /* integer coefficients */
    mtxfile_pattern  /* boolean coefficients (sparsity pattern) */
@};

enum mtxfilesymmetry @{
    mtxfile_general,        /* general, non-symmetric matrix */
    mtxfile_symmetric,      /* symmetric matrix */
    mtxfile_skew_symmetric, /* skew-symmetric matrix */
    mtxfile_hermitian       /* Hermitian matrix */
@};}
@end example


@node Comments
@subsection Comments
Comment lines are stored in a doubly linked list data structure,
@code{struct mtxfilecomments}.
@example
@code{struct mtxfilecomments @{
    struct mtxfilecomment * root;
@};}
@end example
Each comment line in a list is represented with @code{struct
mtxfilecomment}.
@example
@code{struct mtxfilecomment @{
    struct mtxfilecomment * prev;
    struct mtxfilecomment * next;
    char * comment_line;
@};}
@end example
Here, @code{comment_line} is a non-empty, null-terminated string that
must begin with the character @samp{@code{%}}.


@node Size
@subsection Size
The size information in @code{struct mtxfilesize} includes the number
of rows, columns and nonzeros in the underlying matrix or vector.
@example
@code{struct mtxfilesize @{
    int num_rows;
    int num_columns;
    int64_t num_nonzeros;
@};}
@end example

In the case of a matrix, @code{num_rows} and @code{num_columns} are
non-negative integers representing the number of rows and columns in
the matrix, respectively. By convention, vectors are represented as
column vectors. As a result, @code{num_rows} is equal to the number of
vector elements, whereas @code{num_columns} is not used and is
therefore set to @code{-1}.

For matrices and vectors in coordinate format, @code{num_nonzeros} is
the number of entries explicitly stored in the data section of the
Matrix Market file. For matrices and vectors in array format,
@code{num_nonzeros} is not used and is therefore set to @code{-1}.

Given a valid @code{struct mtxfilesize}, the number of lines in the
data section of a Matrix Market file can be obtained by calling
@code{mtxfilesize_num_data_lines}.
@example
@code{int mtxfilesize_num_data_lines(
    const struct mtxfilesize * size,
    enum mtxfile_symmetry symmetry,
    int64_t * num_data_lines);}
@end example
Briefly explained, @code{num_data_lines} will contain the number of
data lines in data section of a Matrix Market file with the given size
line and symmetry. More specifically, @code{num_data_lines} is set to
@itemize
@item @code{num_nonzeros}, if @code{num_nonzeros} is non-negative; or
@item @code{num_rows*num_columns}, if @code{num_rows} and @code{num_columns} are both non-negative and @code{symmetry} is @samp{mtxfile_general}; or
@item @code{num_rows*(num_rows+1)/2}, if @code{num_rows} is non-negative and equal to @code{num_columns}, and @code{symmetry} is @samp{mtxfile_symmetric} or @samp{mtxfile_hermitian}; or
@item @code{num_rows*(num_rows-1)/2}, if @code{num_rows} is non-negative and equal to @code{num_columns}, and @code{symmetry} is @samp{mtxfile_skew_symmetric}; or
@item @code{num_rows}, if @code{num_rows} is non-negative.
@end itemize


@node Precision
@subsection Precision
The Matrix Market file format stores matrix or vector values as
integers or decimal numbers in ASCII text. The format is thus quite
flexible, since it does not prescribe any limits or fixed precision on
the values that are stored.

In practice, however, it is more convenient to convert matrix and
vector values to integer or floating point types. The
@code{mtxprecision} enum type can be used to choose between single
(32-bit) and double (64-bit) precision at runtime.

@cindex precision
@c @cindex half precision
@cindex single precision
@cindex double precision
@c @cindex quad precision
@c @cindex arbitrary precision
@tindex mtxprecision
@example
@code{enum mtxprecision @{
@c    mtx_half,             /* Half (16-bit) precision */
    mtx_single,           /* Single (32-bit) precision */
    mtx_double,           /* Double (64-bit) precision */
@c    mtx_quadruple,        /* Double (64-bit) precision */
@c    mtx_arbitrary,        /* Arbitrary precision */
@};}
@end example
@c Arbitrary precision support is based on GNU GMP for integers and GNU
@c MPFR for floating point numbers.


@node Data
@subsection Data

Matrix or vector values are stored in an array whose type depends on
the object, format and field of the Matrix Market file, as well as the
chosen precision.  The appropriate array can therefore be accessed
through the @code{mtxfiledata} union type, which is shown below.
Furthermore, as explained in @ref{Size}, the length of the array
corresponds to the number of data lines in the Matrix Market file.
The length thus depends on the size and symmetry of the Matrix Market
object, and is obtained by calling @code{mtxfilesize_num_data_lines}.
@example
@code{union mtxfiledata @{
    /* Array formats */
    float * array_real_single;
    double * array_real_double;
    float (* array_complex_single)[2];
    double (* array_complex_double)[2];
    int32_t * array_integer_single;
    int64_t * array_integer_double;

    /* Matrix coordinate formats */
    struct mtxfile_matrix_coordinate_real_single *
        matrix_coordinate_real_single;
    struct mtxfile_matrix_coordinate_real_double *
        matrix_coordinate_real_double;
    struct mtxfile_matrix_coordinate_complex_single *
        matrix_coordinate_complex_single;
    struct mtxfile_matrix_coordinate_complex_double *
        matrix_coordinate_complex_double;
    struct mtxfile_matrix_coordinate_integer_single *
        matrix_coordinate_integer_single;
    struct mtxfile_matrix_coordinate_integer_double *
        matrix_coordinate_integer_double;
    struct mtxfile_matrix_coordinate_pattern *
        matrix_coordinate_pattern;

    /* Vector coordinate formats */
    struct mtxfile_vector_coordinate_real_single *
        vector_coordinate_real_single;
    struct mtxfile_vector_coordinate_real_double *
        vector_coordinate_real_double;
    struct mtxfile_vector_coordinate_complex_single *
        vector_coordinate_complex_single;
    struct mtxfile_vector_coordinate_complex_double *
        vector_coordinate_complex_double;
    struct mtxfile_vector_coordinate_integer_single *
        vector_coordinate_integer_single;
    struct mtxfile_vector_coordinate_integer_double *
        vector_coordinate_integer_double;
    struct mtxfile_vector_coordinate_pattern *
        vector_coordinate_pattern;
@};}
@end example

@cindex array format
For a matrix or vector in array format, values are stored in the union
member @code{array_@var{field}_@var{precision}}, which is an array of
type
@itemize
@item @code{float} or @code{double} if @code{field} is @samp{mtxfile_real} and @code{precision} is @samp{mtx_single} or @samp{mtx_double}, respectively; or
@item @code{float (*)[2]} or @code{double (*)[2]} if @code{field} is @samp{mtxfile_complex} and @code{precision} is @samp{mtx_single} or @samp{mtx_double}, respectively; or
@item @code{int32_t} or @code{int64_t} if @code{field} is @samp{mtxfile_integer} and @code{precision} is @samp{mtx_single} or @samp{mtx_double}, respectively.
@end itemize
Note that the type used for complex values, e.g., @code{float (*)[2]},
denotes a pointer to an array of size @code{2}. Thus, complex values
are accessed using two-dimensional array indexing, e.g.,
@code{array_complex_single[i][j]}. The first index, @code{i},
indicates the position in array of complex vector or matrix values,
while the second index, @code{j}, is @code{0} for the real part and
@code{1} for the imaginary part of the complex number. Also, note that
matrices or vectors in array format may not have @code{field} set to
@samp{mtxfile_pattern}.

@cindex coordinate format
@tindex mtxfile_matrix_coordinate_real_single
@tindex mtxfile_matrix_coordinate_real_double
@tindex mtxfile_matrix_coordinate_complex_single
@tindex mtxfile_matrix_coordinate_complex_double
@tindex mtxfile_matrix_coordinate_integer_single
@tindex mtxfile_matrix_coordinate_integer_double
@tindex mtxfile_matrix_coordinate_pattern
For a matrix in coordinate format, values are stored in the union
member @code{matrix_coordinate_@var{field}_@var{precision}}, which is
an array of type @code{struct
mtxfile_matrix_@var{field}_@var{precision}}, where @code{@var{field}}
is the field associated with the matrix and @code{@var{precision}} is
the chosen precision. The struct data types for each combination of
field and precision are shown below.
@example
@code{struct mtxfile_matrix_coordinate_real_single @{
    int i, j;    /* row and column index */
    float a;     /* nonzero value */
@};

struct mtxfile_matrix_coordinate_real_double @{
    int i, j;    /* row and column index */
    double a;    /* nonzero value */
@};

struct mtxfile_matrix_coordinate_complex_single @{
    int i, j;    /* row and column index */
    float a[2];  /* real and imaginary parts of nonzero value */
@};

struct mtxfile_matrix_coordinate_complex_double @{
    int i, j;    /* row and column index */
    double a[2]; /* real and imaginary parts of nonzero value */
@};

struct mtxfile_matrix_coordinate_integer_single @{
    int i, j;    /* row and column index */
    int32_t a;   /* nonzero value */
@};

struct mtxfile_matrix_coordinate_integer_double @{
    int i, j;    /* row and column index */
    int64_t a;   /* nonzero value */
@};

struct mtxfile_matrix_coordinate_pattern @{
    int i, j;    /* row and column index */
@};}
@end example
Note that there is no precision associated with matrices whose
@code{field} is @samp{mtxfile_pattern}. Instead, the presence of a
nonzero value with row index @code{i} and column index @code{j}
indicates that the matrix has a value of @code{1} at position
@code{(i,j)}.

@tindex mtxfile_vector_coordinate_real_single
@tindex mtxfile_vector_coordinate_real_double
@tindex mtxfile_vector_coordinate_complex_single
@tindex mtxfile_vector_coordinate_complex_double
@tindex mtxfile_vector_coordinate_integer_single
@tindex mtxfile_vector_coordinate_integer_double
@tindex mtxfile_vector_coordinate_pattern
Vectors in coordinate format are treated similarly to matrices, except
that the column index is omitted. More specifically, vector values are
stored in the union member
@code{vector_coordinate_@var{field}_@var{precision}}, which is an
array of type @code{struct
mtxfile_vector_@var{field}_@var{precision}}, where @code{@var{field}}
is the field associated with the vector and @code{@var{precision}} is
the chosen precision. The struct data types for each combination of
field and precision are shown below.
@example
@code{struct mtxfile_vector_coordinate_real_single @{
    int i;       /* row index */
    float a;     /* nonzero value */
@};

struct mtxfile_vector_coordinate_real_double @{
    int i;       /* row index */
    double a;    /* nonzero value */
@};

struct mtxfile_vector_coordinate_complex_single @{
    int i;       /* row index */
    float a[2];  /* real and imaginary parts of nonzero value */
@};

struct mtxfile_vector_coordinate_complex_double @{
    int i;       /* row index */
    double a[2]; /* real and imaginary parts of nonzero value */
@};

struct mtxfile_vector_coordinate_integer_single @{
    int i;       /* row index */
    int32_t a;   /* nonzero value */
@};

struct mtxfile_vector_coordinate_integer_double @{
    int i;       /* row index */
    int64_t a;   /* nonzero value */
@};

struct mtxfile_vector_coordinate_pattern @{
    int i;       /* row index */
@};}
@end example
Note that there is no precision associated with vectors whose
@code{field} is @samp{mtxfile_pattern}. Instead, the presence of a
nonzero value with index @code{i} indicates that the vector has a
value of @code{1} at position @code{i}.


@node Reading and writing Matrix Market files
@section Reading and writing Matrix Market files
In most cases, matrices and vectors are obtained by reading from a
file in Matrix Market format. These files are typically named with a
@file{.mtx} extension, so we refer to them here as @file{mtx} files.
This section describes how to use libmtx to read or write matrices and
vectors to and from files in Matrix Market format.

@subsection Reading Matrix Market files
@findex mtxfile_fread
To read an @file{mtx} file from a @code{FILE} stream, use the
function @code{mtxfile_fread}:
@example
@code{int mtxfile_fread(
    struct mtxfile * mtxfile,
    enum mtxprecision precision,
    FILE * f,
    int * lines_read,
    int64_t * bytes_read,
    size_t line_max,
    char * linebuf);}
@end example
If successful, @code{MTX_SUCCESS} is returned, and @code{mtxfile} will
contain the matrix or vector. The user is responsible for calling
@code{mtxfile_free} to free any storage allocated by
@code{mtxfile_fread}. Otherwise, if @code{mtxfile_fread} fails, an
error code is returned and @code{lines_read} and @code{bytes_read} are
used to indicate the line number and byte of the Matrix Market file at
which the error was encountered. @code{lines_read} and
@code{bytes_read} are ignored if they are set to @samp{NULL}.

Moreover, @code{precision} is used to choose the precision for storing
the values of matrix or vector entries, as described in
@ref{Precision}. If @code{linebuf} is not @samp{NULL}, then it must
point to an array that can hold a null-terminated string whose length
(including the terminating null-character) is at most @code{line_max}.
This buffer is used for reading lines from the stream. Otherwise, if
@code{linebuf} is @samp{NULL}, then a temporary buffer is allocated
and used, and the maximum line length is determined by calling
@code{sysconf()} with @code{_SC_LINE_MAX}.

@findex mtxfile_gzread
If libmtx is built with zlib support, then @code{mtxfile_gzread} can
be used to read gzip-compressed @file{mtx} files.
@example
@code{int mtxfile_gzread(
    struct mtxfile * mtxfile,
    enum mtxprecision precision,
    gzFile f,
    int * lines_read,
    int64_t * bytes_read,
    size_t line_max,
    char * linebuf);}
@end example

@findex mtxfile_read
For convenience, the function @code{mtxfile_read} can be used to read
an @file{mtx} file from a given path.
@example
@code{int mtxfile_read(
    struct mtxfile * mtxfile,
    enum mtxprecision precision,
    const char * path,
    bool gzip,
    int * lines_read,
    int64_t * bytes_read);}
@end example
The file is assumed to be gzip-compressed if @code{gzip} is
@samp{true}, and uncompressed otherwise. If @code{path} is @samp{-},
then the standard input stream is used.

@subsection Writing Matrix Market files
@findex mtxfile_fwrite
To write an @file{mtx} file to a @code{FILE} stream, use the
function @code{mtxfile_fwrite}:
@example
@code{int mtxfile_fwrite(
    const struct mtxfile * mtxfile,
    FILE * f,
    const char * fmt,
    int64_t * bytes_written);}
@end example
If successful, @code{MTX_SUCCESS} is returned, and the matrix or
vector was written to the @code{FILE} stream. Moreover, if it is not
@samp{NULL}, then the number of bytes written to the stream is
returned in @code{bytes_written}.

The @code{fmt} argument may optionally be used to specify a format
string for outputting of numerical values. If @code{fmt} is
@samp{NULL}, then the format specifier @samp{%g} is used to print
floating point numbers with enough digits to ensure correct round-trip
conversion from decimal text and back. Otherwise, the given format
string is used to print numerical values. The format string follows
the conventions of @code{printf}. If the field of @code{mtxfile} is
@samp{mtxfile_real} or @samp{mtxfile_complex}, then the format
specifiers @samp{%e}, @samp{%E}, @samp{%f}, @samp{%F}, @samp{%g} or
@samp{%G} may be used. If the field is @samp{mtxfile_integer}, then
the format specifier must be @samp{%d}. The format string is ignored
if the field is @samp{mtxfile_pattern}. Field width and precision may
be specified (e.g., @samp{%3.1f}), but variable field width and
precision (e.g., @samp{%*.*f}), as well as length modifiers (e.g.,
@samp{%Lf}) are not allowed.

Note that the locale is temporarily changed to "C" to ensure that
locale-specific settings, such as the type of decimal point, do not
affect output.


@findex mtxfile_gzwrite
If libmtx is built with zlib support, then @code{mtxfile_gzwrite} can
be used to write gzip-compressed @file{mtx} files.
@example
@code{int mtxfile_gzwrite(
    const struct mtxfile * mtxfile,
    gzFile f,
    const char * fmt,
    int64_t * bytes_written);}
@end example

@findex mtxfile_write
For convenience, the function @code{mtxfile_write} can be used to write
an @file{mtx} file to a given path.
@example
@code{int mtxfile_write(
    const struct mtxfile * mtxfile,
    const char * path,
    bool gzip,
    const char * fmt,
    int64_t * bytes_written);}
@end example
The file is written as a gzip-compressed stream if @code{gzip} is
@samp{true}, and uncompressed otherwise. If @code{path} is @samp{-},
then the standard output stream is used.


@node Creating matrices and vectors
@section Creating matrices and vectors

A number of functions are provided to construct matrices and vectors
in the Matrix Market format, represented by objects of type
@code{struct mtx}.  These functions encompass both vectors and
matrices in the array (i.e., dense) storage format, as well as
coordinate (i.e., sparse) format.

@cindex matrix allocation
@cindex matrix creation
@cindex vector allocation
@cindex vector creation
For convenience, libmtx provides @emph{allocation} functions for
allocating matrices and vectors when the size is known, but the values
of the matrix or vector entries are not given.  In this case, storage
is allocated for data, but initialising the data is left to the user.
(See, for example, @ref{Setting matrix and vector values}.)  In
addition, libmtx provides @emph{creation} functions, where the matrix
or vector entries are provided by the user to be copied to the newly
allocated storage.

@findex mtx_free
Finally, it is important to note that the matrix and vector allocation
and creation routines will allocate their own storage for matrix or
vector data.  As a result, once the user is finished with an object of
type @code{struct mtx}, it is important to free any allocated storage
by calling @code{mtx_free}:
@example
@code{void mtx_free(struct mtx * mtx);}
@end example

The following subsections describe the various matrix and vector
allocation and creation functions.

@node Creating dense vectors
@subsection Creating dense vectors

@cindex dense vector
The file @file{libmtx/vector/array.h} defines functions for
constructing dense vectors in array format.  For example, a dense
vector of real, single-precision floating point values is created with
the function:
@findex mtx_init_vector_array_real
@example
@code{int mtx_init_vector_array_real(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const float * data);}
@end example
Like most functions provided by libmtx,
@code{mtx_init_vector_array_real} returns @code{MTX_SUCCESS} if it is
successful.  In this case, the @code{mtx} argument points to the newly
constructed vector, whose comment lines and nonzero data have been
copied from the @code{comment_lines} and @code{data} arguments,
respectively.  Note that @code{comment_lines} must be an array whose
length is at least equal to @code{num_comment_lines}, containing
non-empty, null-terminated strings beginning with @samp{@code{%}}.
Also, @code{data} must be an array whose length is at least equal to
@code{size}.  If, for some reason, a call to
@code{mtx_init_vector_array_real} fails, then an error code is
returned, which may be handled as described in @ref{Error handling}.

There are similar functions for other fields, which differ only in the
type of the @code{data} argument.
@findex mtx_init_vector_array_double
@findex mtx_init_vector_array_complex
@findex mtx_init_vector_array_integer
@example
@code{int mtx_init_vector_array_double(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const double * data);

int mtx_init_vector_array_complex(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const float * data);

int mtx_init_vector_array_integer(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const int * data);}
@end example

@findex mtx_alloc_vector_array_real
If, for some reason, one does not wish to set the values of a vector
when constructing it, then it is possible to instead allocate a vector
without providing the values, for example, by using
@code{mtx_alloc_vector_array_real}:
@example
@code{int mtx_alloc_vector_array_real(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size);}
@end example
On success, @code{mtx} points to a newly constructed vector, whose
header and size information has been initialised appropriately, and
the comment lines have been copied from
@code{comment_lines}. Moreover, @code{mtx->data} is a newly allocated
@code{float} array of length @code{size}.  Note that the values of
@code{mtx->data} remain uninitialised, and it is up to the user to
initialise these values correctly before they are used.  (See, for
example, @ref{Setting matrix and vector values}.)

Naturally, there are analogous functions with the same signature for
vectors with @code{double}, @code{complex} and @code{integer} fields.


@node Creating sparse vectors
@subsection Creating sparse vectors

@cindex sparse vector
The file @file{libmtx/vector/coordinate.h} defines functions for
constructing sparse vectors in coordinate format.  On the whole,
sparse vectors are allocated and created in a similar manner to dense
vectors, but some additional arguments must be provided.

@findex mtx_alloc_vector_coordinate_real
For example, to allocate a sparse vector of real, single-precision
floating point values without initialising the associated nonzero
entries, the function @code{mtx_alloc_vector_coordinate_real} may be
used:
@example
@code{int mtx_alloc_vector_coordinate_real(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int size);}
@end example
If the call is successful, @code{mtx} points to a newly constructed
vector.  The @code{object}, @code{format} and @code{field} member
variables are set to @code{mtx_vector}, @code{mtx_coordinate} and
@code{mtx_real}, respectively.  Moreover, @code{sorting},
@code{ordering} and @code{assembly} are set to @code{mtx_unsorted},
@code{mtx_unordered} and @code{mtx_unassembled}.  (Note that
@code{symmetry} and @code{triangle} are not used for vectors.)
Comment lines are copied from the provided @code{comment_lines} array.

Furthermore, @code{mtx->data} is a newly allocated array of length
@code{size}, where each array element is now of the type @code{struct
mtx_vector_coordinate_real}, which was defined in @ref{Matrix Market
files}.  In addition, the number of rows of the sparse vector must be
provided explicitly, since it will typically not match the number of
entries in the @code{data} array.

@findex mtx_init_vector_coordinate_real
If the vector data is already available in the form of an array of
elements of type @code{struct mtx_vector_coordinate_real}, then a
sparse vector may instead be created with the function
@code{mtx_init_vector_coordinate_real}:
@example
@code{int mtx_init_vector_coordinate_real(
    struct mtx * mtx,
    enum mtx_sorting sorting,
    enum mtx_ordering ordering,
    enum mtx_assembly assembly,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int size,
    const struct mtx_vector_coordinate_real * data);}
@end example
As before, if everything goes well, @code{MTX_SUCCESS} is returned and
@code{mtx} points to a newly constructed vector.  Its comment lines
and nonzero data have now been copied from the @code{comment_lines}
and @code{data} arguments, respectively.  Here, @code{data} must be an
array whose length is at least equal to @code{size}, where the type of
each array element is @code{struct mtx_vector_coordinate_real}.  The
number of rows of the sparse vector is provided explicitly, since it
will typically not match the number of entries in the @code{data}
array.  Further, @code{sorting}, @code{ordering} and @code{assembly}
may be prescribed if these are known.  Otherwise, default values of
@code{mtx_unsorted}, @code{mtx_unordered} and @code{mtx_unassembled}
should be used.

@findex mtx_init_vector_coordinate_double
@findex mtx_init_vector_coordinate_complex
@findex mtx_init_vector_coordinate_integer
@findex mtx_init_vector_coordinate_pattern
@findex mtx_alloc_vector_coordinate_double
@findex mtx_alloc_vector_coordinate_complex
@findex mtx_alloc_vector_coordinate_integer
@findex mtx_alloc_vector_coordinate_pattern
There are analogous functions for allocating and creating sparse
vectors with @code{double}, @code{complex}, @code{integer} or
@code{pattern} fields.  The signatures of these functions are the same
as above, except that the type of the @code{data} argument or the
@code{mtx->data} struct member will instead be @code{struct
mtx_vector_coordinate_@var{field}}, where @code{@var{field}} is any of
the above-mentioned fields.  See @ref{Matrix Market files} for
the definitions of the struct data types for each field.


@node Creating dense matrices
@subsection Creating dense matrices

@findex mtx_init_matrix_array_real
The file @file{libmtx/matrix/array.h} defines functions for
constructing dense matrices.  Roughly speaking, these functions
imitate the ones for allocating and initialising dense vectors in
array format, but there are a few additional arguments that must be
provided in the case of matrices.

For example, a dense matrix with real, single precision floating point
coefficients is allocated with the function
@code{mtx_alloc_matrix_array_real}:
@example
@code{int mtx_alloc_matrix_array_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    enum mtx_triangle triangle,
    enum mtx_sorting sorting,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns);}
@end example
Here, @code{mtx} must be a pointer to a @code{struct mtx} object,
which, on the successful completion of
@code{mtx_alloc_matrix_array_real}, will contain a newly constructed
dense matrix in array format.

The @code{symmetry} argument is used to specify symmetry properties of
the matrix.  If @code{symmetry} is @code{mtx_symmetric},
@code{mtx_skew_symmetric} or @code{mtx_hermitian}, then
@code{triangle} must be either @code{mtx_lower_triangular} or
@code{mtx_upper_triangular} to indicate which triangle of the matrix
is stored in @code{data}.  Otherwise, if @code{symmetry} is
@code{mtx_general}, then @code{triangle} must be
@code{mtx_nontriangular}.

Further, @code{sorting} is either @code{mtx_row_major} for a row major
ordering of the matrix entries, or @code{mtx_column_major} otherwise.

Comment lines are handled in the same way as for creating vectors in
array or coordinate format.  That is, @code{comment_lines} is an array
of length @code{num_comment_lines}, consisting of non-empty,
null-terminated strings beginning with @samp{@code{%}}, which will be
copied when constructing the matrix.

Finally, the number of rows and columns of the matrix is prescribed by
@code{num_rows} and @code{num_columns}.  These are used to allocated
storage for matrix entries, which is held by @code{mtx->data}.  In the
case of an unsymmetric matrix, the array @code{data} must contain at
least @code{num_rows*num_columns} values of type @code{float}.
Otherwise, the allocated size of the array @code{mtx->data} depends on
@code{num_rows}, @code{num_columns}, @code{symmetry} and
@code{triangle}, as described in @ref{Size}.

If the values of the matrix elements are already on hand, then a
matrix can be allocated and populated at once by calling
@code{mtx_init_matrix_array_real}:
@example
@code{int mtx_init_matrix_array_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    enum mtx_triangle triangle,
    enum mtx_sorting sorting,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns,
    const float * data);}
@end example
The arguments are the same as for @code{mtx_alloc_matrix_array_real},
except for the array @code{data}, which is now used for copying the
value of each matrix entry to @code{mtx->data}.  The minimum size of
the @code{data} array depends on @code{num_rows}, @code{num_columns},
@code{symmetry} and @code{triangle}, as described in @ref{Size}.

@findex mtx_alloc_matrix_array_double
@findex mtx_alloc_matrix_array_complex
@findex mtx_alloc_matrix_array_integer
@findex mtx_init_matrix_array_double
@findex mtx_init_matrix_array_complex
@findex mtx_init_matrix_array_integer
Similar allocation and initialisation functions are provided for
@code{double}, @code{complex} and @code{integer} matrices, where the
type of the @code{data} argument is modified accordingly.


@node Creating sparse matrices
@subsection Creating sparse matrices

@cindex sparse matrix
@findex mtx_init_matrix_coordinate_real
The file @file{libmtx/matrix/coordinate.h} defines functions for
constructing sparse matrices in coordinate format.  Although this is
mostly similar to creating dense matrices, there are a few additional
arguments that must be given.  Also, in the case where data is
provided, then it is given as an array of structs that depends on the
matrix field.

To allocate a sparse matrix in coordinate format with real,
single-precision floating point coefficients, the function
@code{mtx_alloc_matrix_coordinate_real} is used:
@example
@code{int mtx_alloc_matrix_coordinate_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns,
    int64_t size);}
@end example
On success, a newly constructed matrix will be stored in @code{mtx},
which will have @code{object}, @code{format} and @code{field} set to
@code{mtx_matrix}, @code{mtx_coordinate} and @code{mtx_real},
respectively.  The symmetry of the matrix is specified with
@code{symmetry}.  By default, the values of the additional header
information, @code{triangle}, @code{sorting}, @code{ordering} and
@code{assembly}, are set to @code{mtx_nontriangular},
@code{mtx_unsorted}, @code{mtx_unordered} and @code{mtx_unassembled}.
These can, of course, be changed by the user, if the matrix is known
to possess some additional properties or structure.

As with the other matrix and vector creation routines,
@code{comment_lines} is an array of @code{num_comment_lines}
null-terminated strings beginning with @samp{@code{%}}.  These strings
will be copied to the newly constructed matrix.

The size of the matrix is specified with @code{num_rows} and
@code{num_columns}.  The number of explicitly stored matrix entries is
given by @code{size}, which is used to allocate storage for the array
@code{mtx->data}.  That is, @code{mtx->data} will point to an array of
@code{size} values of type @code{struct mtx_matrix_coordinate_real}.

@tindex mtx_matrix_coordinate_real
Recall that the different data types for matrices in coordinate format
depend on the @var{@code{field}} value of the Matrix Market header, as
described in @ref{Data}.  Recall that, in the above case, where
@var{@code{field}} is @code{real}, the appropriate data type is:
@example
@code{struct mtx_matrix_coordinate_real @{
    int i, j; /* row and column index */
    float a;  /* nonzero value */
@};}
@end example

To allocate and initialise a sparse matrix in coordinate format with
real, single-precision floating point coefficients, the function
@code{mtx_init_matrix_coordinate_real} is used:
@example
@code{int mtx_init_matrix_coordinate_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    enum mtx_triangle triangle,
    enum mtx_sorting sorting,
    enum mtx_ordering ordering,
    enum mtx_assembly assembly,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns,
    int64_t size,
    const struct mtx_matrix_coordinate_real * data);}
@end example
This works in the same way as the allocation function above, but the
difference is that the matrix entries are copied from the array
@code{data} to the newly allocated array @code{mtx->data}.

Also, the fields that make up the additional header information are
provided by the arguments @code{triangle}, @code{sorting},
@code{ordering} and @code{assembly}.  Unless the matrix is known to
possess some particular structure, these values should normally be set
to @code{mtx_nontriangular}, @code{mtx_unsorted}, @code{mtx_unordered}
and @code{mtx_unassembled}.

@findex mtx_alloc_matrix_coordinate_double
@findex mtx_alloc_matrix_coordinate_complex
@findex mtx_alloc_matrix_coordinate_integer
@findex mtx_alloc_matrix_coordinate_pattern
@findex mtx_init_matrix_coordinate_double
@findex mtx_init_matrix_coordinate_complex
@findex mtx_init_matrix_coordinate_integer
@findex mtx_init_matrix_coordinate_pattern
Sparse coordinate matrices can also be created for other fields,
(@code{double}, @code{complex}, @code{integer} or @code{pattern}) by
using analogous functions, where the type of the @code{data} argument
is adjusted to match the appropriate field.


@node Setting matrix and vector values
@subsection Setting matrix and vector values

@findex mtx_set_zero
The function @code{mtx_set_zero} can be used to set all of the values
associated with the entries of a matrix or vector to zero:
@example
@code{int mtx_set_zero(struct mtx * mtx);}
@end example

@findex mtx_set_constant_real
@findex mtx_set_constant_double
@findex mtx_set_constant_complex
@findex mtx_set_constant_integer
Depending on the field, there are several functions that may be used
to set all (nonzero) values associated of a matrix or vector to some
given, constant value:
@example
@code{int mtx_set_constant_real(struct mtx * mtx, float a);
int mtx_set_constant_double(struct mtx * mtx, double a);
int mtx_set_constant_complex(struct mtx * mtx, float a, float b);
int mtx_set_constant_integer(struct mtx * mtx, int a);}
@end example


@node Copying matrices and vectors
@subsection Copying matrices and vectors

@cindex copying matrices
@cindex copying vectors
The function @code{mtx_copy} can be used to make a copy of an
existing matrix or vector:
@findex mtx_copy
@example
@code{int mtx_copy(
    struct mtx * destmtx,
    const struct mtx * srcmtx);}
@end example


@node Extracting submatrices
@subsection Extracting submatrices

@cindex submatrix
@findex mtx_matrix_submatrix
The function @code{mtx_matrix_submatrix} can be used to obtain a
submatrix of a @code{struct mtx} object, which consists of the nonzero
entries from a given set of rows and columns.
@example
@code{int mtx_matrix_submatrix(
    const struct mtx * mtx,
    const struct mtx_index_set * rows,
    const struct mtx_index_set * columns,
    struct mtx * submatrix);}
@end example
Note that @code{mtx_matrix_submatrix} currently only works for
@code{struct mtx} objects where @code{format} is
@code{mtx_coordinate}.

The @code{rows} and @code{columns} arguments are index sets, as
described in @ref{Index sets}.  These are used to determine which rows
and columns to include in the submatrix.


@node Transposing sorting and reordering
@section Transposing, sorting and reordering

This section describes operations related to sorting and permuting
matrices and vectors, as well as transposing matrices and reordering
the rows and columns of sparse matrices.


@node Transposing
@subsection Transposing

@cindex transpose
@findex mtx_matrix_transpose
The function @code{mtx_matrix_transpose} can be used to transpose a
square matrix represented by a @code{struct mtx} object.
@example
@code{int mtx_matrix_transpose(
    struct mtx * mtx);}
@end example
The matrix is transposed in-place. This currently only works for
matrices where @code{format} is @code{mtx_coordinate} and
@code{symmetry} is either @code{mtx_general} or @code{mtx_symmetric}.


@node Sorting
@subsection Sorting

@cindex sorting
@findex mtx_sort
Sometimes, it is convenient to sort the nonzeros of a sparse matrix or
vector in the coordinate format. This can be achieved with the
function @code{mtx_sort}:
@example
@code{int mtx_sort(
    struct mtx * mtx,
    struct mtx_sorting sorting);}
@end example
If successful, @code{mtx_sort} returns @code{MTX_SUCCESS}, and
@code{mtx} will have its nonzeros sorted according to the order
specified by @code{sorting}. If @code{mtx->format} is @code{mtx_array},
then @code{mtx_sort} does nothing.

@cindex sorting
@cindex row major
@cindex column major
@tindex mtx_sorting
The enum type @code{mtx_sorting} is used to enumerate different ways
of sorting matrix entries.
@example
@code{enum mtx_sorting @{
    mtx_unsorted,       /* unsorted matrix nonzeros */
    mtx_row_major,      /* row major ordering */
    mtx_column_major,   /* column major ordering */
@};}
@end example
For matrices and vectors in array format (i.e., dense matrices or
vectors), the default is to assume that they are sorted in row major
order (@code{mtx_row_major}).  Otherwise, matrices and vectors are
generally unsorted (@code{mtx_unsorted}).


@node Permuting
@subsection Permuting

@cindex reordering
@cindex permutation
There are a number of commonly used schemes for reordering the rows
and columns of sparse matrices with the goal of reducing fill-in that
occurs during the factorisation stage of sparse direct solvers or
improving the performance of operations such as sparse matrix-vector
multiplication.

@findex mtx_permute
The function @code{mtx_permute} can be used to permute the rows and/or
columns of a matrix or vector.
@example
@code{int mtx_permute_matrix(
    struct mtx * mtx,
    const int * row_permutation,
    const int * column_permutation);}
@end example
The permutation used to reorder the rows is specified through the
array @code{row_permutation}, whose length is @code{mtx->num_rows} and
should be a permutation of the integers
@code{1,2,...,mtx->num_rows}. Similarly, @code{column_permutation} is
used to reorder the columns based on a permutation of
@code{1,2,...,mtx->num_columns}. If @code{row_permutation} or
@code{column_permutation} is @samp{NULL}, then no permutation is
applied to the rows or columns, respectively.


@node Reordering
@subsection Reordering

@cindex ordering
@cindex reordering
@cindex unordered
@cindex Reverse Cuthill-McKee
@cindex RCM
@tindex mtx_ordering
The enum type @code{mtx_ordering} is used to enumerate different
orderings or permutations of the rows and columns of a
matrix. Reordering a sparse matrix is typically done to improve
performance, for example, through reduced fill-in for matrix
factorisations or better data locality.
@example
@code{enum mtx_ordering @{
    mtx_unordered,      /* general, unordered matrix */
    mtx_rcm,            /* Reverse Cuthill-McKee ordering */
@};}
@end example
Matrices are generally assumed to be unordered.  See @ref{Transposing
sorting and reordering} for more on reordering matrices and vectors.

@findex mtx_matrix_reorder
The function @code{mtx_matrix_reorder} reorders the rows and columns
of a matrix according to the specified algorithm.
@example
@code{int mtx_matrix_reorder(
    struct mtx * mtx,
    int ** row_permutation,
    int ** column_permutation,
    enum mtx_ordering ordering,
    int rcm_starting_vertex)}
@end example

Some algorithms may pose certain requirements on the matrix. For
example, the Reverse Cuthill-McKee ordering requires a matrix to be
square and in coordinate format.

If successful, @code{mtx_matrix_reorder} returns @code{MTX_SUCCESS}, and the
rows and columns of mtx have been reordered. If @code{row_permutation} is
not @samp{NULL} and the rows of a matrix were indeed reordered, then
@code{row_permutation} is set to point to a newly allocated array
containing the row permutation.  Furthermore, if @code{column_permutation}
is not @samp{NULL}, then @code{column_permutation} may be set to point to an
array containing the column permutation. However, this is only done if
the columns were also reordered and the permutation is not
symmetric. That is, if the row and column permutations are the same,
then only @code{row_permutation} is set and @code{*column_permutation} is set to
@samp{NULL}.

If either of the @code{row_permutation} or @code{column_permutation} pointers
are set, then the user is responsible for calling @code{free} to free the
underlying storage.


@node Reverse Cuthill-McKee (RCM)
@subsection Reverse Cuthill-McKee (RCM)
@findex mtx_matrix_reorder_rcm
The function @code{mtx_matrix_reorder_rcm} can be used to reorder the
rows and columns of a symmetric sparse matrix according to the Reverse
Cuthill-McKee algorithm (@pxref{E. Cuthill and J. McKee (1969)}).

The RCM algorithm considers the matrix as the adjacency matrix of an
undirected graph. The vertices of the graph, which correspond to rows
and column of the matrix, are ordered by choosing a starting vertex
and then traversing the graph in a breadth-first search, where the
vertices at each level are ordered ascendingly by degree. In the end,
after traversing the entire graph, the obtained ordering is reversed.
@example
@code{int mtx_matrix_reorder_rcm(
    struct mtx * mtx,
    int ** permutation,
    int starting_vertex);}
@end example
If successful, @code{mtx_matrix_reorder_rcm} returns
@code{MTX_SUCCESS}, and the rows and columns of @code{mtx} have been
reordered according to the Reverse Cuthill-McKee algorithm. If
@code{permutation} is not @samp{NULL}, then the underlying pointer is
set to point to a newly allocated array containing the permutation
used to reorder the rows and columns of @code{mtx}.

Note that the sparse matrix must be square and already sorted in row
major order (see @code{mtx_sort}). It is assumed that the matrix
sparsity pattern is symmetric. Also, note that if the graph consists
of multiple connected components, then only the component to which the
starting vertex belongs is reordered.


@node Basic linear algebra operations
@section Basic linear algebra operations

The libmtx C library implements a subset of the Basic Linear
Algebra Subprograms (BLAS) routines. For dense operations,
libmtx relies on optimised, third-party BLAS libraries, such
as OpenBLAS (@url{https://www.openblas.net/}). Otherwise,
libmtx uses internal routines for sparse matrix operations.

The BLAS functions for @code{mtx} vectors and matrices are defined
in the file @code{libmtx/mtx/blas.h}.

@node Level 1 BLAS operations
@subsection Level 1 BLAS operations
The following Level 1 BLAS operations are supported:
@cindex vector scaling
@cindex @code{scal}
@cindex vector addition
@cindex @code{axpy}
@cindex dot product
@cindex @code{dot}
@cindex @code{nrm2}
@cindex Euclidean norm
@itemize
@item @code{scal} --- @code{x = a*x}
@item @code{axpy} --- @code{y = a*x + y}
@item @code{dot} --- dot product
@item @code{nrm2} --- Euclidean norm
@end itemize
The corresponding function signatures are:
@findex mtx_sscal
@findex mtx_dscal
@findex mtx_saxpy
@findex mtx_daxpy
@findex mtx_sdot
@findex mtx_ddot
@findex mtx_snrm2
@findex mtx_dnrm2
@example
@code{int mtx_sscal(float a, struct mtx *x);
int mtx_dscal(double a, struct mtx *x);

int mtx_saxpy(float a, const struct mtx *x, struct mtx *y);
int mtx_daxpy(double a, const struct mtx *x, struct mtx *y);

int mtx_sdot(const struct mtx *x, const struct mtx *y, float *dot);
int mtx_ddot(const struct mtx *x, const struct mtx *y, double *dot);

int mtx_snrm2(const struct mtx *x, const struct mtx *y, float *nrm2);
int mtx_dnrm2(const struct mtx *x, const struct mtx *y, double *nrm2);}
@end example


@node Level 2 BLAS operations
@subsection Level 2 BLAS operations
The following Level 2 BLAS operations are supported:
@cindex @code{gemv}
@cindex matrix-vector multiply
@itemize
@item @code{gemv} --- matrix-vector multiply, @code{y = alpha*A*x + beta*y}
@end itemize

The corresponding function signatures are:
@findex mtx_sgemv
@findex mtx_dgemv
@example
@code{int mtx_sgemv(
    float alpha,
    const struct mtx * A,
    const struct mtx * x,
    float beta,
    struct mtx * y);

int mtx_dgemv(
    double alpha,
    const struct mtx * A,
    const struct mtx * x,
    double beta,
    struct mtx * y);}
@end example


@c @node Level 3 BLAS operations
@c @subsection Level 3 BLAS operations
@c The following Level 3 BLAS operations are supported:
@c @cindex @code{gemm}
@c @cindex matrix-matrix multiply
@c @itemize
@c @item @code{gemm} --- matrix-matrix multiply
@c @end itemize








@c @node Additional header types
@c @subsection Additional header types

@c For the sake of convenience, libmtx also defines some additional enum
@c types that are not stored explicitly as part of the Matrix Market
@c format.  This extra information can sometimes be provided by the user
@c (or by libmtx) to keep track of various facts concerning the
@c underlying matrix or vector.  These facts may not always be stated
@c explicitly in the Matrix Market file itself.  For example, it is often
@c useful to know whether a matrix is sorted or not, which can be used to
@c improve the efficiency of some computations.

@c The enum types for this extra header information are
@c @c code{mtxprecision},
@c @code{mtx_triangle}, @code{mtx_sorting}, @code{mtx_ordering} and
@c @code{mtx_assembly}.

@c @cindex triangular matrix
@c @cindex lower triangular matrix
@c @cindex upper triangular matrix
@c @tindex mtx_triangle
@c The enum type @code{mtx_triangle} is used to describe whether or not
@c the matrix entries stored for a particular matrix belong to the upper
@c or lower triangular part of the matrix, or both.  Note that the term
@c triangular is still used for non-square matrices, even though the term
@c trapezoidal would be more accurate.
@c @example
@c @code{enum mtx_triangle @{
@c     mtx_nontriangular,    /* nonzero above, below or on main diagonal */
@c     mtx_lower_triangular, /* zero above main diagonal */
@c     mtx_upper_triangular, /* zero below main diagonal */
@c     mtx_diagonal,         /* zero above and below main diagonal */
@c @};}
@c @end example
@c For matrices in array format (i.e., dense matrices) that are
@c symmetric, Hermitian or skew-symmetric the default is to assume that
@c the lower triangular part is stored (@code{mtx_lower_triangular}).
@c Otherwise, the matrix is assumed to be non-triangular
@c (@code{mtx_nontriangular}).

@c @cindex assembly
@c @tindex mtx_assembly
@c @tindex mtx_assembled
@c @tindex mtx_unassembled
@c The enum type @code{mtx_assembly} is used to indicate whether or not a
@c sparse matrix can contain more than one value for a given row and
@c column index.  In other words, an unassembled matrix often contains
@c several entries associated with a single location in the matrix.  Many
@c sparse matrix operations will only produce correct results whenever
@c these duplicate matrix entries have been added together first, a
@c procedure generally referred to as @dfn{assembly}.  An assembled
@c matrix may only contain a single, unique value for each nonzero matrix
@c location.
@c @example
@c @code{enum mtx_assembly @{
@c     mtx_unassembled, /* unassembled; duplicate nonzeros allowed. */
@c     mtx_assembled,   /* assembled; duplicate nonzeros not allowed. */
@c @};}
@c @end example
@c In general, it is assumed that matrices are not assembled
@c (@code{mtx_unassembled}) and duplicate entries may be present.
