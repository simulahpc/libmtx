@c This file is part of libmtx.
@c Copyright (C) 2021 James D. Trotter
@c
@c libmtx is free software: you can redistribute it and/or
@c modify it under the terms of the GNU General Public License as
@c published by the Free Software Foundation, either version 3 of the
@c License, or (at your option) any later version.
@c
@c libmtx is distributed in the hope that it will be useful,
@c but WITHOUT ANY WARRANTY; without even the implied warranty of
@c MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
@c General Public License for more details.
@c
@c You should have received a copy of the GNU General Public License
@c along with libmtx.  If not, see
@c <https://www.gnu.org/licenses/>.
@c
@c Authors: James D. Trotter <james@simula.no>
@c Last modified: 2021-08-09
@c
@c libmtx User Guide: Matrix Market objects.

@node Matrices and vectors
@chapter Matrices and vectors

This chapter provides a detailed explanation of how to work with
matrices and vectors using the libmtx C library.  For now, we are
concerned with matrices and vectors that belong locally to a single
machine or node.  For matrices and vectors that are distributed among
multiple nodes, see @ref{Distributed matrices and vectors}.

For any user-facing types and functions, the library uses the
convention of prefixing their names with @code{mtx_}. This makes it
easier to avoid possible name clashes with other code when using
libmtx.

@menu
* Error handling:: How to handle errors when working with the libmtx C library.
* Matrix Market data types:: Basic data types for representing Matrix Market objects.
* Creating matrices and vectors:: Functions for creating matrices and vectors.
* Reading and writing Matrix Market files:: Functions for reading from and writing to files in Matrix Market format.
* Transposing sorting and reordering:: Transposing, sorting and reordering matrices and vectors.
* Basic linear algebra operations:: Basic linear algebra
@end menu


@node Error handling
@section Error handling
Functions in the libmtx C library generally return a status code that
either indicates success (represented by the status code
@code{MTX_SUCCESS}) or a specific error.  Valid error codes correspond
to values of the type @code{enum mtx_error}, which is defined in the
file @file{libmtx/error.h} along with some error handling
functions.

@findex mtx_strerror
The function @code{mtx_strerror} can be used to give a string
containing a description of a given error code.
@example
@code{const char * mtx_strerror(int err);}
@end example
Here, the integer @code{err} should correspond to one of the error
codes from the @code{mtx_error} enum type.

@code{mtx_strerror} is typically used as shown in the example below.
@example
@code{  FILE * f = fopen("test.mtx", "r");

  struct mtx mtx;
  int line, column;
  int err = mtx_fread(&mtx, f, &line, &column);
  if (err) @{
      fprintf(stderr, "Error: test.mtx:%d:%d: %s\n",
              line, column, mtx_strerror(err));
      fclose(f);
  @}}
@end example
If @code{mtx_fread} returns @code{MTX_ERR_INVALID_MTX_OBJECT}, for
example, then the following message will be printed:
@example
@code{Error: test.mtx:1:1: invalid Matrix Market object}
@end example


@node Matrix Market data types
@section Matrix Market data types

This section describes the basic data types used to represent objects
in the Matrix Market file format.

@tindex struct mtx
@tindex mtx
The file @file{libmtx/mtx/mtx.h} defines the @code{struct mtx} type.
The main purpose of @code{struct mtx} is to describe objects in the
Matrix Market format.  However, this single, abstract data type is
used throughout libmtx to represent both matrices and vectors with
different underlying storage formats.  The two most important formats
are those used in Matrix Market files, namely the array format, which
is used for dense matrices and vectors, and the coordinate format,
which is used for sparse matrices and vectors.  In addition, libmtx
defines a few other, advanced storage formats that are suitable for
sparse matrices with a particular structure.

The definition of the @code{mtx} struct is shown below.
@example
@code{struct mtx @{
  /* Header */
  enum mtx_object object;
  enum mtx_format format;
  enum mtx_field field;
  enum mtx_symmetry symmetry;

  /* Extra header info */
@c  enum mtx_precision precision;
  enum mtx_triangle triangle;
  enum mtx_sorting sorting;
  enum mtx_ordering ordering;
  enum mtx_assembly assembly;

  /* Comments */
  int num_comment_lines;
  char ** comment_lines;

  /* Size */
  int num_rows;
  int num_columns;
  int64_t num_nonzeros;
  int64_t size;
  int64_t nonzero_size;

  /* Data */
  void * data;
@};}
@end example

Roughly speaking, the @code{mtx} struct consists of four parts:
header information, comment lines, size information, and data.

The following sections provide a detailed explanation of the
@code{mtx} struct members and their data types.


@node Header types
@subsection Header types

@tindex mtx_object
@tindex mtx_format
@tindex mtx_field
@tindex mtx_symmetry
The four enum types, @code{mtx_object}, @code{mtx_format},
@code{mtx_field} and @code{mtx_symmetry} are used to represent values
that appear in the Matrix Market header (see @ref{Header line}).  The
meaning of the values associated with these types is described in
detail in @ref{Matrix Market file format}.
@example
@code{enum mtx_object @{
    mtx_matrix,
    mtx_vector
@};

enum mtx_format @{
    mtx_array,     /* array of dense matrix values */
    mtx_coordinate /* coordinate format of sparse matrix values */
@};

enum mtx_field @{
    mtx_real,    /* single-precision floating point coefficients */
    mtx_double,  /* double-precision floating point coefficients */
    mtx_complex, /* single-precision floating point complex
                  * coefficients */
    mtx_integer, /* integer coefficients */
    mtx_pattern  /* boolean coefficients (sparsity pattern) */
@};

enum mtx_symmetry @{
    mtx_general,        /* general, non-symmetric matrix */
    mtx_symmetric,      /* symmetric matrix */
    mtx_skew_symmetric, /* skew-symmetric matrix */
    mtx_hermitian       /* Hermitian matrix */
@};}
@end example


@node Additional header types
@subsection Additional header types

For the sake of convenience, libmtx also defines some additional enum
types that are not stored explicitly as part of the Matrix Market
format.  This extra information can sometimes be provided by the user
(or by libmtx) to keep track of various facts concerning the
underlying matrix or vector.  These facts may not always be stated
explicitly in the Matrix Market file itself.  For example, it is often
useful to know whether a matrix is sorted or not, which can be used to
improve the efficiency of some computations.

The enum types for this extra header information are
@c code{mtx_precision},
@code{mtx_triangle}, @code{mtx_sorting}, @code{mtx_ordering} and
@code{mtx_assembly}.

@c @cindex precision
@c @cindex half precision
@c @cindex single precision
@c @cindex double precision
@c @cindex quad precision
@c @cindex arbitrary precision
@c @tindex mtx_precision
@c @example
@c @code{enum mtx_precision @{
@c     mtx_half,             /* Half (16-bit) precision */
@c     mtx_single,           /* Single (32-bit) precision */
@c     mtx_double,           /* Double (64-bit) precision */
@c     mtx_quadruple,        /* Double (64-bit) precision */
@c     mtx_arbitrary,        /* Arbitrary precision */
@c @};}
@c @end example
@c Arbitrary precision support is based on GNU GMP for integers and GNU
@c MPFR for floating point numbers.

@cindex triangular matrix
@cindex lower triangular matrix
@cindex upper triangular matrix
@tindex mtx_triangle
The enum type @code{mtx_triangle} is used to describe whether or not
the matrix entries stored for a particular matrix belong to the upper
or lower triangular part of the matrix, or both.  Note that the term
triangular is still used for non-square matrices, even though the term
trapezoidal would be more accurate.
@example
@code{enum mtx_triangle @{
    mtx_nontriangular,    /* nonzero above, below or on main diagonal */
    mtx_lower_triangular, /* zero above main diagonal */
    mtx_upper_triangular, /* zero below main diagonal */
    mtx_diagonal,         /* zero above and below main diagonal */
@};}
@end example
For matrices in array format (i.e., dense matrices) that are
symmetric, Hermitian or skew-symmetricâ€š the default is to assume that
the lower triangular part is stored (@code{mtx_lower_triangular}).
Otherwise, the matrix is assumed to be non-triangular
(@code{mtx_nontriangular}).

@cindex sorting
@cindex row major
@cindex column major
@tindex mtx_sorting
The enum type @code{mtx_sorting} is used to enumerate different ways
of sorting matrix entries.
@example
@code{enum mtx_sorting @{
    mtx_unsorted,       /* unsorted matrix nonzeros */
    mtx_row_major,      /* row major ordering */
    mtx_column_major,   /* column major ordering */
@};}
@end example
For matrices and vectors in array format (i.e., dense matrices or
vectors), the default is to assume that they are sorted in row major
order (@code{mtx_row_major}).  Otherwise, matrices and vectors are
generally unsorted (@code{mtx_unsorted}).

@cindex ordering
@cindex reordering
@cindex unordered
@cindex Reverse Cuthill-McKee
@cindex RCM
@tindex mtx_ordering
The enum type @code{mtx_ordering} is used to enumerate different
orderings or permutations of the rows and columns of a
matrix. Reordering a sparse matrix is typically done to improve
performance, for example, through reduced fill-in for matrix
factorisations or better data locality.
@example
@code{enum mtx_ordering @{
    mtx_unordered,      /* general, unordered matrix */
    mtx_rcm,            /* Reverse Cuthill-McKee ordering */
@};}
@end example
Matrices are generally assumed to be unordered.  See @ref{Transposing
sorting and reordering} for more on reordering matrices and vectors.

@cindex assembly
@tindex mtx_assembly
@tindex mtx_assembled
@tindex mtx_unassembled
The enum type @code{mtx_assembly} is used to indicate whether or not a
sparse matrix can contain more than one value for a given row and
column index.  In other words, an unassembled matrix often contains
several entries associated with a single location in the matrix.  Many
sparse matrix operations will only produce correct results whenever
these duplicate matrix entries have been added together first, a
procedure generally referred to as @dfn{assembly}.  An assembled
matrix may only contain a single, unique value for each nonzero matrix
location.
@example
@code{enum mtx_assembly @{
    mtx_unassembled, /* unassembled; duplicate nonzeros allowed. */
    mtx_assembled,   /* assembled; duplicate nonzeros not allowed. */
@};}
@end example
In general, it is assumed that matrices are not assembled
(@code{mtx_unassembled}) and duplicate entries may be present.


@node Comments
@subsection Comments
Comments are stored in the array @code{comment_lines}, whose length is
equal to @code{num_comment_lines}.  Each entry in the array (e.g.,
@code{comment_lines[i]}, where @code{i=0,1,...,num_comment_lines-1})
is a non-empty, null-terminated string that must begin with the
character @samp{@code{%}}.


@node Size information
@subsection Size information
The size information in @code{struct mtx} includes @code{num_rows},
@code{num_columns} and @code{num_nonzeros}, which represent the number
of rows, column and nonzeros, respectively. In addition, @code{size}
is the number of entries explicitly stored in the @code{data}
array.

Vectors are represented as row vectors by default, so that
@code{num_rows} is equal to the number of elements and
@code{num_columns} is not used, so it is set equal to @code{-1}.
Conversely, column vectors have @code{num_columns} set equal to the
number of elements and @code{num_rows} is set to @code{-1}.

For vectors in the array format, @code{num_nonzeros} and @code{size}
are equal, and they both represent the number of vector elements.
Otherwise, for vectors in coordinate format, @code{size} is the number
of entries stored in the @code{data} array, whereas
@code{num_nonzeros} is either @code{-1} or equal to the number of
vector elements that are nonzero.  (Recall that a given vector element
may have multiple entries in the @code{data} array.)

In the case of a matrix, @code{num_nonzeros} is either @code{-1} or it
is equal to the total number of nonzeros in the matrix, including any
nonzeros that are not explicitly stored due to symmetry.  Note that
@code{num_nonzeros} is generally different from @code{size} for
symmetric, Hermitian or skew-symmetric matrices.  Moreover, even for
general, unsymmetric sparse matrices, @code{size} may not be equal
@code{num_nonzeros}, if there are multiple entries corresponding to a
single matrix element.  Both @code{size} and @code{num_nonzeros}
depend on the matrix format and symmetry as described below.

@itemize

@item
If @code{format} is @code{mtx_array} and @code{symmetry} is
@code{mtx_general}, then @code{size} and @code{num_nonzeros} are equal
to @code{num_rows*num_columns}.

@item
If @code{format} is @code{mtx_array}, @code{symmetry} is
@code{mtx_symmetric} or @code{mtx_hermitian} and @code{triangle} is
@code{mtx_lower_triangular}, then @code{size} is the number of nonzero
entries on or below the main diagonal, which is equal to
@code{num_rows*(num_rows+1)/2} if @code{num_rows <= num_columns} or
@code{num_columns*(num_columns+1)/2+(num_rows-num_columns)*num_columns}
otherwise.  If @code{triangle} is @code{mtx_upper_triangular}, then
@code{size} is instead the number of nonzero entries on or above the
main diagonal, which is equal to @code{num_columns*(num_columns+1)/2}
if @code{num_columns <= num_rows} or
@code{num_rows*(num_rows+1)/2+(num_columns-num_rows)*num_rows}
otherwise.

@item
If @code{symmetry} is @code{mtx_skew_symmetric}, then @code{size} is
the number of nonzero entries below the main diagonal. If @code{format} is
@code{mtx_array}, then @code{size} is equal to
@code{num_rows*(num_columns-1)/2}, where @code{num_rows} is equal to
@code{num_columns} due to skew-symmetry.

If @code{format} is @code{mtx_array}, @code{symmetry} is
@code{mtx_skew_symmetric} and @code{triangle} is
@code{mtx_lower_triangular}, then @code{size} is the number of nonzero
entries below the main diagonal, which is equal to
@code{num_rows*(num_rows-1)/2} if @code{num_rows <= num_columns} or
@code{num_columns*(num_columns-1)/2+(num_rows-num_columns)*num_columns}
otherwise.  If @code{triangle} is @code{mtx_upper_triangular}, then
@code{size} is instead the number of nonzero entries on or above the
main diagonal, which is equal to @code{num_columns*(num_columns-1)/2}
if @code{num_columns <= num_rows} or
@code{num_rows*(num_rows-1)/2+(num_columns-num_rows)*num_rows}
otherwise.

@end itemize

Finally, @code{nonzero_size} is the size (in bytes) of each nonzero
stored in the @code{data} array.


@node Data
@subsection Data

Nonzero matrix or vector entries are stored in the array @code{data},
whose type depends on the values of @code{object}, @code{format} and
@code{field}, as described below.
@c The type of @code{data} also depends on @code{precision}.

First, consider the case where @code{format} is @code{mtx_array}. If
@code{field} is @code{mtx_real}, @code{mtx_double} or @code{mtx_integer},
then @code{data} is an array of @code{size} values of type
@code{float}, @code{double} or @code{int}, respectively. Otherwise, if
@code{field} is @code{mtx_complex}, then @code{data} is an array of
@code{2*size} values of type @code{float}. (Note that the combination
of a matrix or vector with the @code{mtx_array} format and the
@code{mtx_pattern} field is not currently supported, though, in
principle, it could be implemented in the form of a bitmap.)

@cindex sparse matrix
@tindex mtx_matrix_coordinate_real
@tindex mtx_matrix_coordinate_double
@tindex mtx_matrix_coordinate_complex
@tindex mtx_matrix_coordinate_integer
@tindex mtx_matrix_coordinate_pattern
@tindex mtx_vector_coordinate_real
@tindex mtx_vector_coordinate_double
@tindex mtx_vector_coordinate_complex
@tindex mtx_vector_coordinate_integer
@tindex mtx_vector_coordinate_pattern
Second, if @code{format} is @code{mtx_coordinate}, then @code{data} is
an array of @code{size} values of type @code{struct
mtx_@var{object}_coordinate_@var{field}}. Here @code{@var{object}} is
@code{matrix} or @code{vector}, corresponding to the @code{object}
member of the @code{mtx} struct. Similarly, @code{@var{field}} is
either @code{real}, @code{double}, @code{complex}, @code{integer} or
@code{pattern}, corresponding to the @code{field} member of the
@code{mtx} struct.

The file @file{libmtx/matrix/coordinate.h} contains definitions
of data types for representing nonzero values of sparse matrices in
coordinate format. For matrices with different fields, the data types
are shown below:
@example
@code{struct mtx_matrix_coordinate_real @{
    int i, j; /* row and column index */
    float a;  /* nonzero value */
@};

struct mtx_matrix_coordinate_double @{
    int i, j; /* row and column index */
    double a; /* nonzero value */
@};

struct mtx_matrix_coordinate_complex @{
    int i, j;     /* row and column index */
    float a, b;   /* real and imaginary parts of nonzero value */
@};

struct mtx_matrix_coordinate_integer @{
    int i, j; /* row and column index */
    int a;    /* nonzero value */
@};

struct mtx_matrix_coordinate_pattern @{
    int i, j; /* row and column index */
@};}
@end example

The corresponding data types for sparse vectors are defined in the
file @file{libmtx/vector/coordinate.h}. These data types are
almost identical to the ones used for sparse matrices, except that the
column index is omitted:
@example
@code{struct mtx_vector_coordinate_real @{
    int i;    /* row index */
    float a;  /* nonzero value */
@};

struct mtx_vector_coordinate_double @{
    int i;    /* row index */
    double a; /* nonzero value */
@};

struct mtx_vector_coordinate_complex @{
    int i;        /* row index */
    float a, b;   /* real and imaginary parts of nonzero value */
@};

struct mtx_vector_coordinate_integer @{
    int i;    /* row index */
    int a;    /* nonzero value */
@};

struct mtx_vector_coordinate_pattern @{
    int i; /* row index */
@};}
@end example


@node Creating matrices and vectors
@section Creating matrices and vectors

A number of functions are provided to construct matrices and vectors
in the Matrix Market format, represented by objects of type
@code{struct mtx}.  These functions encompass both vectors and
matrices in the array (i.e., dense) storage format, as well as
coordinate (i.e., sparse) format.

@cindex matrix allocation
@cindex matrix creation
@cindex vector allocation
@cindex vector creation
For convenience, libmtx provides @emph{allocation} functions for
allocating matrices and vectors when the size is known, but the values
of the matrix or vector entries are not given.  In this case, storage
is allocated for data, but initialising the data is left to the user.
(See, for example, @ref{Setting matrix and vector values}.)  In
addition, libmtx provides @emph{creation} functions, where the matrix
or vector entries are provided by the user to be copied to the newly
allocated storage.

@findex mtx_free
Finally, it is important to note that the matrix and vector allocation
and creation routines will allocate their own storage for matrix or
vector data.  As a result, once the user is finished with an object of
type @code{struct mtx}, it is important to free any allocated storage
by calling @code{mtx_free}:
@example
@code{void mtx_free(struct mtx * mtx);}
@end example

The following subsections describe the various matrix and vector
allocation and creation functions.

@node Creating dense vectors
@subsection Creating dense vectors

@cindex dense vector
The file @file{libmtx/vector/array.h} defines functions for
constructing dense vectors in array format.  For example, a dense
vector of real, single-precision floating point values is created with
the function:
@findex mtx_init_vector_array_real
@example
@code{int mtx_init_vector_array_real(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const float * data);}
@end example
Like most functions provided by libmtx,
@code{mtx_init_vector_array_real} returns @code{MTX_SUCCESS} if it is
successful.  In this case, the @code{mtx} argument points to the newly
constructed vector, whose comment lines and nonzero data have been
copied from the @code{comment_lines} and @code{data} arguments,
respectively.  Note that @code{comment_lines} must be an array whose
length is at least equal to @code{num_comment_lines}, containing
non-empty, null-terminated strings beginning with @samp{@code{%}}.
Also, @code{data} must be an array whose length is at least equal to
@code{size}.  If, for some reason, a call to
@code{mtx_init_vector_array_real} fails, then an error code is
returned, which may be handled as described in @ref{Error handling}.

There are similar functions for other fields, which differ only in the
type of the @code{data} argument.
@findex mtx_init_vector_array_double
@findex mtx_init_vector_array_complex
@findex mtx_init_vector_array_integer
@example
@code{int mtx_init_vector_array_double(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const double * data);

int mtx_init_vector_array_complex(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const float * data);

int mtx_init_vector_array_integer(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size,
    const int * data);}
@end example

@findex mtx_alloc_vector_array_real
If, for some reason, one does not wish to set the values of a vector
when constructing it, then it is possible to instead allocate a vector
without providing the values, for example, by using
@code{mtx_alloc_vector_array_real}:
@example
@code{int mtx_alloc_vector_array_real(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int size);}
@end example
On success, @code{mtx} points to a newly constructed vector, whose
header and size information has been initialised appropriately, and
the comment lines have been copied from
@code{comment_lines}. Moreover, @code{mtx->data} is a newly allocated
@code{float} array of length @code{size}.  Note that the values of
@code{mtx->data} remain uninitialised, and it is up to the user to
initialise these values correctly before they are used.  (See, for
example, @ref{Setting matrix and vector values}.)

Naturally, there are analogous functions with the same signature for
vectors with @code{double}, @code{complex} and @code{integer} fields.


@node Creating sparse vectors
@subsection Creating sparse vectors

@cindex sparse vector
The file @file{libmtx/vector/coordinate.h} defines functions for
constructing sparse vectors in coordinate format.  On the whole,
sparse vectors are allocated and created in a similar manner to dense
vectors, but some additional arguments must be provided.

@findex mtx_alloc_vector_coordinate_real
For example, to allocate a sparse vector of real, single-precision
floating point values without initialising the associated nonzero
entries, the function @code{mtx_alloc_vector_coordinate_real} may be
used:
@example
@code{int mtx_alloc_vector_coordinate_real(
    struct mtx * mtx,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int size);}
@end example
If the call is successful, @code{mtx} points to a newly constructed
vector.  The @code{object}, @code{format} and @code{field} member
variables are set to @code{mtx_vector}, @code{mtx_coordinate} and
@code{mtx_real}, respectively.  Moreover, @code{sorting},
@code{ordering} and @code{assembly} are set to @code{mtx_unsorted},
@code{mtx_unordered} and @code{mtx_unassembled}.  (Note that
@code{symmetry} and @code{triangle} are not used for vectors.)
Comment lines are copied from the provided @code{comment_lines} array.

Furthermore, @code{mtx->data} is a newly allocated array of length
@code{size}, where each array element is now of the type @code{struct
mtx_vector_coordinate_real}, which was defined in @ref{Matrix Market
data types}.  In addition, the number of rows of the sparse vector
must be provided explicitly, since it will typically not match the
number of entries in the @code{data} array.

@findex mtx_init_vector_coordinate_real
If the vector data is already available in the form of an array of
elements of type @code{struct mtx_vector_coordinate_real}, then a
sparse vector may instead be created with the function
@code{mtx_init_vector_coordinate_real}:
@example
@code{int mtx_init_vector_coordinate_real(
    struct mtx * mtx,
    enum mtx_sorting sorting,
    enum mtx_ordering ordering,
    enum mtx_assembly assembly,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int size,
    const struct mtx_vector_coordinate_real * data);}
@end example
As before, if everything goes well, @code{MTX_SUCCESS} is returned and
@code{mtx} points to a newly constructed vector.  Its comment lines
and nonzero data have now been copied from the @code{comment_lines}
and @code{data} arguments, respectively.  Here, @code{data} must be an
array whose length is at least equal to @code{size}, where the type of
each array element is @code{struct mtx_vector_coordinate_real}.  The
number of rows of the sparse vector is provided explicitly, since it
will typically not match the number of entries in the @code{data}
array.  Further, @code{sorting}, @code{ordering} and @code{assembly}
may be prescribed if these are known.  Otherwise, default values of
@code{mtx_unsorted}, @code{mtx_unordered} and @code{mtx_unassembled}
should be used.

@findex mtx_init_vector_coordinate_double
@findex mtx_init_vector_coordinate_complex
@findex mtx_init_vector_coordinate_integer
@findex mtx_init_vector_coordinate_pattern
@findex mtx_alloc_vector_coordinate_double
@findex mtx_alloc_vector_coordinate_complex
@findex mtx_alloc_vector_coordinate_integer
@findex mtx_alloc_vector_coordinate_pattern
There are analogous functions for allocating and creating sparse
vectors with @code{double}, @code{complex}, @code{integer} or
@code{pattern} fields.  The signatures of these functions are the same
as above, except that the type of the @code{data} argument or the
@code{mtx->data} struct member will instead be @code{struct
mtx_vector_coordinate_@var{field}}, where @code{@var{field}} is any of
the above-mentioned fields.  See @ref{Matrix Market data types} for
the definitions of the struct data types for each field.


@node Creating dense matrices
@subsection Creating dense matrices

@findex mtx_init_matrix_array_real
The file @file{libmtx/matrix/array.h} defines functions for
constructing dense matrices.  Roughly speaking, these functions
imitate the ones for allocating and initialising dense vectors in
array format, but there are a few additional arguments that must be
provided in the case of matrices.

For example, a dense matrix with real, single precision floating point
coefficients is allocated with the function
@code{mtx_alloc_matrix_array_real}:
@example
@code{int mtx_alloc_matrix_array_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    enum mtx_triangle triangle,
    enum mtx_sorting sorting,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns);}
@end example
Here, @code{mtx} must be a pointer to a @code{struct mtx} object,
which, on the successful completion of
@code{mtx_alloc_matrix_array_real}, will contain a newly constructed
dense matrix in array format.

The @code{symmetry} argument is used to specify symmetry properties of
the matrix.  If @code{symmetry} is @code{mtx_symmetric},
@code{mtx_skew_symmetric} or @code{mtx_hermitian}, then
@code{triangle} must be either @code{mtx_lower_triangular} or
@code{mtx_upper_triangular} to indicate which triangle of the matrix
is stored in @code{data}.  Otherwise, if @code{symmetry} is
@code{mtx_general}, then @code{triangle} must be
@code{mtx_nontriangular}.

Further, @code{sorting} is either @code{mtx_row_major} for a row major
ordering of the matrix entries, or @code{mtx_column_major} otherwise.

Comment lines are handled in the same way as for creating vectors in
array or coordinate format.  That is, @code{comment_lines} is an array
of length @code{num_comment_lines}, consisting of non-empty,
null-terminated strings beginning with @samp{@code{%}}, which will be
copied when constructing the matrix.

Finally, the number of rows and columns of the matrix is prescribed by
@code{num_rows} and @code{num_columns}.  These are used to allocated
storage for matrix entries, which is held by @code{mtx->data}.  In the
case of an unsymmetric matrix, the array @code{data} must contain at
least @code{num_rows*num_columns} values of type @code{float}.
Otherwise, the allocated size of the array @code{mtx->data} depends on
@code{num_rows}, @code{num_columns}, @code{symmetry} and
@code{triangle}, as described in @ref{Size information}.

If the values of the matrix elements are already on hand, then a
matrix can be allocated and populated at once by calling
@code{mtx_init_matrix_array_real}:
@example
@code{int mtx_init_matrix_array_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    enum mtx_triangle triangle,
    enum mtx_sorting sorting,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns,
    const float * data);}
@end example
The arguments are the same as for @code{mtx_alloc_matrix_array_real},
except for the array @code{data}, which is now used for copying the
value of each matrix entry to @code{mtx->data}.  The minimum size of
the @code{data} array depends on @code{num_rows}, @code{num_columns},
@code{symmetry} and @code{triangle}, as described in @ref{Size
information}.

@findex mtx_alloc_matrix_array_double
@findex mtx_alloc_matrix_array_complex
@findex mtx_alloc_matrix_array_integer
@findex mtx_init_matrix_array_double
@findex mtx_init_matrix_array_complex
@findex mtx_init_matrix_array_integer
Similar allocation and initialisation functions are provided for
@code{double}, @code{complex} and @code{integer} matrices, where the
type of the @code{data} argument is modified accordingly.


@node Creating sparse matrices
@subsection Creating sparse matrices

@cindex sparse matrix
@findex mtx_init_matrix_coordinate_real
The file @file{libmtx/matrix/coordinate.h} defines functions for
constructing sparse matrices in coordinate format.  Although this is
mostly similar to creating dense matrices, there are a few additional
arguments that must be given.  Also, in the case where data is
provided, then it is given as an array of structs that depends on the
matrix field.

To allocate a sparse matrix in coordinate format with real,
single-precision floating point coefficients, the function
@code{mtx_alloc_matrix_coordinate_real} is used:
@example
@code{int mtx_alloc_matrix_coordinate_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns,
    int64_t size);}
@end example
On success, a newly constructed matrix will be stored in @code{mtx},
which will have @code{object}, @code{format} and @code{field} set to
@code{mtx_matrix}, @code{mtx_coordinate} and @code{mtx_real},
respectively.  The symmetry of the matrix is specified with
@code{symmetry}.  By default, the values of the additional header
information, @code{triangle}, @code{sorting}, @code{ordering} and
@code{assembly}, are set to @code{mtx_nontriangular},
@code{mtx_unsorted}, @code{mtx_unordered} and @code{mtx_unassembled}.
These can, of course, be changed by the user, if the matrix is known
to possess some additional properties or structure.

As with the other matrix and vector creation routines,
@code{comment_lines} is an array of @code{num_comment_lines}
null-terminated strings beginning with @samp{@code{%}}.  These strings
will be copied to the newly constructed matrix.

The size of the matrix is specified with @code{num_rows} and
@code{num_columns}.  The number of explicitly stored matrix entries is
given by @code{size}, which is used to allocate storage for the array
@code{mtx->data}.  That is, @code{mtx->data} will point to an array of
@code{size} values of type @code{struct mtx_matrix_coordinate_real}.

@tindex mtx_matrix_coordinate_real
Recall that the different data types for matrices in coordinate format
depend on the @var{@code{field}} value of the Matrix Market header, as
described in @ref{Data}.  Recall that, in the above case, where
@var{@code{field}} is @code{real}, the appropriate data type is:
@example
@code{struct mtx_matrix_coordinate_real @{
    int i, j; /* row and column index */
    float a;  /* nonzero value */
@};}
@end example

To allocate and initialise a sparse matrix in coordinate format with
real, single-precision floating point coefficients, the function
@code{mtx_init_matrix_coordinate_real} is used:
@example
@code{int mtx_init_matrix_coordinate_real(
    struct mtx * mtx,
    enum mtx_symmetry symmetry,
    enum mtx_triangle triangle,
    enum mtx_sorting sorting,
    enum mtx_ordering ordering,
    enum mtx_assembly assembly,
    int num_comment_lines,
    const char ** comment_lines,
    int num_rows,
    int num_columns,
    int64_t size,
    const struct mtx_matrix_coordinate_real * data);}
@end example
This works in the same way as the allocation function above, but the
difference is that the matrix entries are copied from the array
@code{data} to the newly allocated array @code{mtx->data}.

Also, the fields that make up the additional header information are
provided by the arguments @code{triangle}, @code{sorting},
@code{ordering} and @code{assembly}.  Unless the matrix is known to
possess some particular structure, these values should normally be set
to @code{mtx_nontriangular}, @code{mtx_unsorted}, @code{mtx_unordered}
and @code{mtx_unassembled}.

@findex mtx_alloc_matrix_coordinate_double
@findex mtx_alloc_matrix_coordinate_complex
@findex mtx_alloc_matrix_coordinate_integer
@findex mtx_alloc_matrix_coordinate_pattern
@findex mtx_init_matrix_coordinate_double
@findex mtx_init_matrix_coordinate_complex
@findex mtx_init_matrix_coordinate_integer
@findex mtx_init_matrix_coordinate_pattern
Sparse coordinate matrices can also be created for other fields,
(@code{double}, @code{complex}, @code{integer} or @code{pattern}) by
using analogous functions, where the type of the @code{data} argument
is adjusted to match the appropriate field.


@node Setting matrix and vector values
@subsection Setting matrix and vector values

@findex mtx_set_zero
The function @code{mtx_set_zero} can be used to set all of the values
associated with the entries of a matrix or vector to zero:
@example
@code{int mtx_set_zero(struct mtx * mtx);}
@end example

@findex mtx_set_constant_real
@findex mtx_set_constant_double
@findex mtx_set_constant_complex
@findex mtx_set_constant_integer
Depending on the field, there are several functions that may be used
to set all (nonzero) values associated of a matrix or vector to some
given, constant value:
@example
@code{int mtx_set_constant_real(struct mtx * mtx, float a);
int mtx_set_constant_double(struct mtx * mtx, double a);
int mtx_set_constant_complex(struct mtx * mtx, float a, float b);
int mtx_set_constant_integer(struct mtx * mtx, int a);}
@end example


@node Copying matrices and vectors
@subsection Copying matrices and vectors

@cindex copying matrices
@cindex copying vectors
The function @code{mtx_copy} can be used to make a copy of an
existing matrix or vector:
@findex mtx_copy
@example
@code{int mtx_copy(
    struct mtx * destmtx,
    const struct mtx * srcmtx);}
@end example


@node Extracting submatrices
@subsection Extracting submatrices

@cindex submatrix
@findex mtx_matrix_submatrix
The function @code{mtx_matrix_submatrix} can be used to obtain a
submatrix of a @code{struct mtx} object, which consists of the nonzero
entries from a given set of rows and columns.
@example
@code{int mtx_matrix_submatrix(
    const struct mtx * mtx,
    const struct mtx_index_set * rows,
    const struct mtx_index_set * columns,
    struct mtx * submatrix);}
@end example
Note that @code{mtx_matrix_submatrix} currently only works for
@code{struct mtx} objects where @code{format} is
@code{mtx_coordinate}.

The @code{rows} and @code{columns} arguments are index sets, as
described in @ref{Index sets}.  These are used to determine which rows
and columns to include in the submatrix.


@node Reading and writing Matrix Market files
@section Reading and writing Matrix Market files
The file @file{libmtx/mtx/io.h} defines functions for reading
from and writing to files in Matrix Market format. These files are
typically named with a @file{.mtx} extension, so we refer to them here
as @file{mtx} files.

@findex mtx_fread
To read an @file{mtx} file from a @code{FILE} stream, use the
function:
@example
@code{int mtx_fread(
    struct mtx * mtx,
    FILE * f,
    int * line_number,
    int * column_number);}
@end example
If successful, @code{MTX_SUCCESS} is returned, and @code{mtx} will
contain the matrix or vector represented by the @code{FILE}
stream. The user is responsible for calling @code{mtx_free} to free
any storage that may have been allocated by @code{mtx_fread}.
Otherwise, if @code{mtx_fread} fails, then it will return an error
code, and @code{line_number} and @code{column_number} will indicate
the location in the Matrix Market file at which an error was
encountered.

@findex mtx_fwrite
To write an @file{mtx} file to a @code{FILE} stream, use the function:
@example
@code{int mtx_fwrite(
    const struct mtx * mtx,
    FILE * f,
    const char * format);}
@end example
If successful, @code{MTX_SUCCESS} is returned, and @code{mtx} is
written to the stream @code{f}.

If @code{format} is @code{NULL}, then the format specifier @samp{%d}
is used to print integers and @samp{%f} is used to print floating
point numbers. Otherwise, the given format string is used when
printing numerical values.

The format string follows the conventions of @code{printf}. If the
field is @samp{real}, @samp{double} or @samp{complex}, then the format
specifiers @samp{%e}, @samp{%E}, @samp{%f}, @samp{%F}, @samp{%g} or
@samp{%G} may be used. If the field is @samp{integer}, then the format
specifier must be @samp{%d}. The format string is ignored if the field
is @samp{pattern}. Flags, field width and precision may be specified
(e.g., @samp{%+3.1f}), but variable field width and precision (e.g.,
@samp{%*.*f}), as well as length modifiers (e.g., @samp{%Lf}) are not
allowed.

@findex mtx_gzread
@findex mtx_gzwrite
If libmtx is built with zlib support, then the functions
@code{mtx_gzread} and @code{mtx_gzwrite} can be used to read or
write gzip-compressed @file{mtx} files. The function signatures are the
similar @code{mtx_fread} and @code{mtx_fwrite}:
@example
@code{int mtx_gzread(
    struct mtx * mtx,
    gzFile f,
    int * line_number,
    int * column_number);

int mtx_gzwrite(
    const struct mtx * mtx,
    gzFile f,
    const char * format);}
@end example

@findex mtx_read
@findex mtx_write
Additionally, for convenience, the following functions are provided to
read and write a @code{struct mtx} object to a file specified by a
given path. The file may optionally be compressed using gzip.
@example
@code{int mtx_read(
    struct mtx * mtx,
    const char * path,
    bool gzip,
    int * line_number,
    int * column_number);

int mtx_write(
    const struct mtx * mtx,
    const char * path,
    bool gzip,
    const char * format);}
@end example


@node Transposing sorting and reordering
@section Transposing, sorting and reordering

This section describes operations related to sorting and permuting
matrices and vectors, as well as transposing matrices and reordering
the rows and columns of sparse matrices.


@node Transposing
@subsection Transposing

@cindex transpose
@findex mtx_matrix_transpose
The function @code{mtx_matrix_transpose} can be used to transpose a
square matrix represented by a @code{struct mtx} object.
@example
@code{int mtx_matrix_transpose(
    struct mtx * mtx);}
@end example
The matrix is transposed in-place. This currently only works for
matrices where @code{format} is @code{mtx_coordinate} and
@code{symmetry} is either @code{mtx_general} or @code{mtx_symmetric}.


@node Sorting
@subsection Sorting

@cindex sorting
@findex mtx_sort
Sometimes, it is convenient to sort the nonzeros of a sparse matrix or
vector in the coordinate format. This can be achieved with the
function @code{mtx_sort}:
@example
@code{int mtx_sort(
    struct mtx * mtx,
    struct mtx_sorting sorting);}
@end example
If successful, @code{mtx_sort} returns @code{MTX_SUCCESS}, and
@code{mtx} will have its nonzeros sorted according to the order
specified by @code{sorting}. If @code{mtx->format} is @code{mtx_array},
then @code{mtx_sort} does nothing.


@node Permuting
@subsection Permuting

@cindex reordering
@cindex permutation
There are a number of commonly used schemes for reordering the rows
and columns of sparse matrices with the goal of reducing fill-in that
occurs during the factorisation stage of sparse direct solvers or
improving the performance of operations such as sparse matrix-vector
multiplication.

@findex mtx_permute
The function @code{mtx_permute} can be used to permute the rows and/or
columns of a matrix or vector.
@example
@code{int mtx_permute_matrix(
    struct mtx * mtx,
    const int * row_permutation,
    const int * column_permutation);}
@end example
The permutation used to reorder the rows is specified through the
array @code{row_permutation}, whose length is @code{mtx->num_rows} and
should be a permutation of the integers
@code{1,2,...,mtx->num_rows}. Similarly, @code{column_permutation} is
used to reorder the columns based on a permutation of
@code{1,2,...,mtx->num_columns}. If @code{row_permutation} or
@code{column_permutation} is @code{NULL}, then no permutation is
applied to the rows or columns, respectively.


@node Reordering
@subsection Reordering

@findex mtx_matrix_reorder
The function @code{mtx_matrix_reorder} reorders the rows and columns
of a matrix according to the specified algorithm.
@example
@code{int mtx_matrix_reorder(
    struct mtx * mtx,
    int ** row_permutation,
    int ** column_permutation,
    enum mtx_ordering ordering,
    int rcm_starting_vertex)}
@end example

Some algorithms may pose certain requirements on the matrix. For
example, the Reverse Cuthill-McKee ordering requires a matrix to be
square and in coordinate format.

If successful, @code{mtx_matrix_reorder} returns @code{MTX_SUCCESS}, and the
rows and columns of mtx have been reordered. If @code{row_permutation} is
not @code{NULL} and the rows of a matrix were indeed reordered, then
@code{row_permutation} is set to point to a newly allocated array
containing the row permutation.  Furthermore, if @code{column_permutation}
is not @code{NULL}, then @code{column_permutation} may be set to point to an
array containing the column permutation. However, this is only done if
the columns were also reordered and the permutation is not
symmetric. That is, if the row and column permutations are the same,
then only @code{row_permutation} is set and @code{*column_permutation} is set to
@code{NULL}.

If either of the @code{row_permutation} or @code{column_permutation} pointers
are set, then the user is responsible for calling @code{free} to free the
underlying storage.


@node Reverse Cuthill-McKee (RCM)
@subsection Reverse Cuthill-McKee (RCM)
@findex mtx_matrix_reorder_rcm
The function @code{mtx_matrix_reorder_rcm} can be used to reorder the
rows and columns of a symmetric sparse matrix according to the Reverse
Cuthill-McKee algorithm (@pxref{E. Cuthill and J. McKee (1969)}).

The RCM algorithm considers the matrix as the adjacency matrix of an
undirected graph. The vertices of the graph, which correspond to rows
and column of the matrix, are ordered by choosing a starting vertex
and then traversing the graph in a breadth-first search, where the
vertices at each level are ordered ascendingly by degree. In the end,
after traversing the entire graph, the obtained ordering is reversed.
@example
@code{int mtx_matrix_reorder_rcm(
    struct mtx * mtx,
    int ** permutation,
    int starting_vertex);}
@end example
If successful, @code{mtx_matrix_reorder_rcm} returns
@code{MTX_SUCCESS}, and the rows and columns of @code{mtx} have been
reordered according to the Reverse Cuthill-McKee algorithm. If
@code{permutation} is not @code{NULL}, then the underlying pointer is
set to point to a newly allocated array containing the permutation
used to reorder the rows and columns of @code{mtx}.

Note that the sparse matrix must be square and already sorted in row
major order (see @code{mtx_sort}). It is assumed that the matrix
sparsity pattern is symmetric. Also, note that if the graph consists
of multiple connected components, then only the component to which the
starting vertex belongs is reordered.


@node Basic linear algebra operations
@section Basic linear algebra operations

The libmtx C library implements a subset of the Basic Linear
Algebra Subprograms (BLAS) routines. For dense operations,
libmtx relies on optimised, third-party BLAS libraries, such
as OpenBLAS (@url{https://www.openblas.net/}). Otherwise,
libmtx uses internal routines for sparse matrix operations.

The BLAS functions for @code{mtx} vectors and matrices are defined
in the file @code{libmtx/mtx/blas.h}.

@node Level 1 BLAS operations
@subsection Level 1 BLAS operations
The following Level 1 BLAS operations are supported:
@cindex vector scaling
@cindex @code{scal}
@cindex vector addition
@cindex @code{axpy}
@cindex dot product
@cindex @code{dot}
@cindex @code{nrm2}
@cindex Euclidean norm
@itemize
@item @code{scal} --- @code{x = a*x}
@item @code{axpy} --- @code{y = a*x + y}
@item @code{dot} --- dot product
@item @code{nrm2} --- Euclidean norm
@end itemize
The corresponding function signatures are:
@findex mtx_sscal
@findex mtx_dscal
@findex mtx_saxpy
@findex mtx_daxpy
@findex mtx_sdot
@findex mtx_ddot
@findex mtx_snrm2
@findex mtx_dnrm2
@example
@code{int mtx_sscal(float a, struct mtx *x);
int mtx_dscal(double a, struct mtx *x);

int mtx_saxpy(float a, const struct mtx *x, struct mtx *y);
int mtx_daxpy(double a, const struct mtx *x, struct mtx *y);

int mtx_sdot(const struct mtx *x, const struct mtx *y, float *dot);
int mtx_ddot(const struct mtx *x, const struct mtx *y, double *dot);

int mtx_snrm2(const struct mtx *x, const struct mtx *y, float *nrm2);
int mtx_dnrm2(const struct mtx *x, const struct mtx *y, double *nrm2);}
@end example


@node Level 2 BLAS operations
@subsection Level 2 BLAS operations
The following Level 2 BLAS operations are supported:
@cindex @code{gemv}
@cindex matrix-vector multiply
@itemize
@item @code{gemv} --- matrix-vector multiply, @code{y = alpha*A*x + beta*y}
@end itemize

The corresponding function signatures are:
@findex mtx_sgemv
@findex mtx_dgemv
@example
@code{int mtx_sgemv(
    float alpha,
    const struct mtx * A,
    const struct mtx * x,
    float beta,
    struct mtx * y);

int mtx_dgemv(
    double alpha,
    const struct mtx * A,
    const struct mtx * x,
    double beta,
    struct mtx * y);}
@end example


@c @node Level 3 BLAS operations
@c @subsection Level 3 BLAS operations
@c The following Level 3 BLAS operations are supported:
@c @cindex @code{gemm}
@c @cindex matrix-matrix multiply
@c @itemize
@c @item @code{gemm} --- matrix-matrix multiply
@c @end itemize
